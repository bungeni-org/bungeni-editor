/*
 * generalEditorPanel4.java
 *
 * Created on September 8, 2007, 4:49 PM
 */

package org.bungeni.editor.panels;

import java.awt.Component;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Vector;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPopupMenu;
import javax.swing.JTree;
import javax.swing.ToolTipManager;
import javax.swing.event.TreeExpansionEvent;
import javax.swing.event.TreeWillExpandListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.ExpandVetoException;
import javax.swing.tree.TreeCellRenderer;
import javax.swing.tree.TreePath;
import org.bungeni.db.BungeniClientDB;
import org.bungeni.db.DefaultInstanceFactory;
import org.bungeni.db.QueryResults;
import org.bungeni.db.SettingsQueryFactory;
import org.bungeni.utils.BungeniEditorProperties;
import org.bungeni.editor.actions.EditorActionFactory;
import org.bungeni.editor.actions.IEditorActionEvent;
import org.bungeni.editor.actions.toolbarAction;
import org.bungeni.editor.actions.toolbarSubAction;
import org.bungeni.editor.panels.impl.IFloatingPanel;
import org.bungeni.editor.selectors.SelectorDialogModes;
import org.bungeni.editor.toolbar.BungeniToolbarTargetProcessor;
import org.bungeni.editor.toolbar.BungeniToolbarXMLAdapterNode;
import org.bungeni.editor.toolbar.BungeniToolbarXMLTreeNodeProcessor;
import org.bungeni.editor.toolbar.conditions.BungeniToolbarConditionProcessor;
import org.bungeni.ooo.OOComponentHelper;
import org.bungeni.ooo.utils.CommonExceptionUtils;
import org.bungeni.utils.CommonTreeFunctions;

/**
 *
 * @author  Administrator
 */
public class generalEditorPanel4 extends templatePanel implements IFloatingPanel  {

    private static org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(generalEditorPanel4.class.getName());
    private OOComponentHelper ooDocument;    
    private BungeniClientDB instance;
    private JFrame parentFrame;
    private DefaultMutableTreeNode root;
  //  private DefaultMutableTreeNode[] visibleActionRoots;
    private JPopupMenu popupMenu;
    //XML tree model used by the JTree control
    org.bungeni.editor.toolbar.BungeniToolbarXMLTree toolbarXmlTree ;
    
    private  enum PopupTypeIdentifier {CREATE_EDIT , APPLY_MARKUP, EDIT, SELECT_INSERT, SELECT_EDIT, SYSTEM_ACTION, DOCUMENT_ACTION, GENERAL_ACTION  };
 
    private HashMap<PopupTypeIdentifier, String> popupMap = new HashMap<PopupTypeIdentifier, String>();
    private String property_ActiveDocumentMode = "";
    /** Creates new form generalEditorPanel4 */
    public generalEditorPanel4() {
        log.debug("in constructor initComponents");
        initComponents();
        property_ActiveDocumentMode = org.bungeni.utils.BungeniEditorProperties.getEditorProperty("activeDocumentMode");
        log.debug("in constructor initOthers");
        initOthers();
        log.debug("in constructor initTree");
        initTree();
        
        
     }
    
    public void initUI(){
        
    }
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        generalEditorScrollPane = new javax.swing.JScrollPane();
        treeGeneralEditor = new javax.swing.JTree();

        treeGeneralEditor.setFont(new java.awt.Font("Tahoma", 0, 12));
        generalEditorScrollPane.setViewportView(treeGeneralEditor);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(generalEditorScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 216, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(generalEditorScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 235, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    private void initOthers(){
        instance = new BungeniClientDB (DefaultInstanceFactory.DEFAULT_INSTANCE(), DefaultInstanceFactory.DEFAULT_DB());
        popupMenu = new JPopupMenu();
        
        popupMap.put(PopupTypeIdentifier.APPLY_MARKUP, "Apply Markup");
        popupMap.put(PopupTypeIdentifier.CREATE_EDIT, "Create Section");
        popupMap.put(PopupTypeIdentifier.EDIT, "Edit Section");
        popupMap.put(PopupTypeIdentifier.SELECT_EDIT, "Edit Selection");
        popupMap.put(PopupTypeIdentifier.SELECT_INSERT, "Markup Selection");
        popupMap.put(PopupTypeIdentifier.SYSTEM_ACTION, "Generate System Container");
        popupMap.put(PopupTypeIdentifier.DOCUMENT_ACTION, "Execute Action");
        popupMap.put(PopupTypeIdentifier.GENERAL_ACTION, "Execute Action");
    }
    
    private void initTree(){
        try{
        org.bungeni.editor.toolbar.BungeniToolbarXMLTree toolbarXmlTree = new org.bungeni.editor.toolbar.BungeniToolbarXMLTree(treeGeneralEditor);
        toolbarXmlTree.loadToolbar();
        treeGeneralEditor.addMouseListener(new treeGeneralEditorMouseListener());
        treeGeneralEditor.setCellRenderer(new treeGeneralEditorCellRenderer());
        //-tree-deprecated--CommonTreeFunctions.expandAll(treeGeneralEditor, true);
        treeGeneralEditor.addTreeWillExpandListener(new treeGeneralEditorWillExpandListener());
        CommonTreeFunctions.expandAll(treeGeneralEditor);
        //using a timer to repaint the tree causes very poor tab switching performnce in some cases
        //investigate using fireTreeNodesChanged
        javax.swing.Timer treeGeneralEditorPaintTimer = new javax.swing.Timer(3000, new treeGeneralEditorPaintTimerListener(treeGeneralEditor));
        treeGeneralEditorPaintTimer.start();
        //for note above about firenodeschanged, this has been implemented but works for model refresh ==> tree update.
        //but does not reflect in case of document cursor changes ==> reflecting back to the tree, as this requires a full iteration 
        //of the tree again. so for now implemented both as a treeTimer and fireNodeschanged event refresh
        ToolTipManager.sharedInstance().registerComponent(treeGeneralEditor);
        } catch (Exception ex) {
            log.error("initTree: "+ ex.getMessage());
        }
    }
    private void initTree_old() {
        try {
        toolbarAction rootAction = new toolbarAction("rootAction");
        toolbarAction inivisibleRoot = new toolbarAction("invisibleRootAction");
        toolbarAction selectionAction = new toolbarAction("selectionAction");
        
        root = new DefaultMutableTreeNode(inivisibleRoot);
        DefaultMutableTreeNode editorToolsRoot = new DefaultMutableTreeNode(rootAction);
        DefaultMutableTreeNode editorSelectionToolsRoot = new DefaultMutableTreeNode(selectionAction);
        root.add(editorToolsRoot);
        root.add(editorSelectionToolsRoot);
        
        log.debug("in InitTree");
        if (instance.Connect()) {
            log.debug("about to call createTreeNodes()");
            //create editor tools nodes
            createTreeNodes( editorToolsRoot, true);
            createSelectionNodes(editorSelectionToolsRoot, true);
            //createToolNodes(rootNode, rootAction, instance );
            instance.EndConnect();
        } 
        log.debug("after createTreeNodes()");
        treeGeneralEditor.setModel(new DefaultTreeModel(root));
        treeGeneralEditor.addMouseListener(new treeGeneralEditorMouseListener());
        treeGeneralEditor.setCellRenderer(new treeGeneralEditorCellRenderer());
        //-tree-deprecated--CommonTreeFunctions.expandAll(treeGeneralEditor, true);
        CommonTreeFunctions.expandAll(treeGeneralEditor);
        treeGeneralEditor.setRootVisible(false);
        } catch (Exception ex) {
            log.error("InitTree: exception: " + ex.getMessage());
            log.error("InitTree: stacktrace : " + org.bungeni.ooo.utils.CommonExceptionUtils.getStackTrace(ex));
        }
    }
    
    private void createSelectionNodes(DefaultMutableTreeNode rootNode, boolean recurse) {
        try {
        toolbarAction baseNode = (toolbarAction) rootNode.getUserObject();
        String actionParent = baseNode.action_name();
        Vector<Vector<String>> resultRows = new Vector<Vector<String>>();
        QueryResults query_results;
        query_results = instance.QueryResults(SettingsQueryFactory.Q_FETCH_ZERO_LEVEL_SELECTION_ACTIONS(this.property_ActiveDocumentMode));
        log.debug("createSelectionNodes, query = " + SettingsQueryFactory.Q_FETCH_ZERO_LEVEL_SELECTION_ACTIONS(this.property_ActiveDocumentMode));
        if (query_results == null) 
            return ;
        
        if (query_results.hasResults() ) {
             HashMap columns = query_results.columnNameMap();
             //child actions are present
             //call the result nodes recursively...
             resultRows = query_results.theResults();
             for (int i = 0 ; i < resultRows.size(); i++ ) {
                   //get the results row by row into a string vector
                   Vector<java.lang.String> tableRow = new Vector<java.lang.String>();
                   tableRow = resultRows.elementAt(i);
                   toolbarSubAction subAction = new toolbarSubAction(tableRow, columns);
                   //String displayText = tableRow.elementAt((Integer)columns.get("ACTION_DISPLAY_TEXT") -1 );
                   log.debug("createSelectionNodes : "+ subAction.toString());
                   DefaultMutableTreeNode node = new DefaultMutableTreeNode(subAction);
                   //add child actions to this parent selection action 
                   addSelectionActionChildNodes(node);
                   rootNode.add(node);
               }
        }
        } catch (Exception ex) {
            log.error ("createSelecitonNodes, Exception : "+ ex.getMessage());
            log.error("createSelecitonNodes, StackTrace : "+ org.bungeni.ooo.utils.CommonExceptionUtils.getStackTrace(ex));
        }
    }
   
    private void addSelectionActionChildNodes(DefaultMutableTreeNode parentSelectionNode) {
        toolbarSubAction parentSubAction = (toolbarSubAction) parentSelectionNode.getUserObject();
        String query = SettingsQueryFactory.Q_FETCH_CHILDREN_SELECTION_ACTIONS(this.property_ActiveDocumentMode, parentSubAction.parent_action_name());
        QueryResults qr = instance.QueryResults(query);
        Vector<Vector<String>> resultRows = new Vector<Vector<String>>();
       
        if (qr == null ) return;
        if (qr.hasResults()) {
            HashMap columns = qr.columnNameMap();
            resultRows = qr.theResults();
            for (int i = 0; i < resultRows.size(); i++) {
                   //get the results row by row into a string vector
                   Vector<java.lang.String> tableRow = new Vector<java.lang.String>();
                   tableRow = resultRows.elementAt(i);
                   toolbarSubAction subAction = new toolbarSubAction(tableRow, columns);
                   DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(subAction);
                   parentSelectionNode.add(childNode);
            }
        }
        
        return;
    }
    
    private void createTreeNodes(DefaultMutableTreeNode rootNode, boolean recurse) {
        try {
        toolbarAction baseNode = (toolbarAction) rootNode.getUserObject();
        String actionParent = baseNode.action_name();
        //HashMap results = new HashMap();
        Vector<Vector<String>> resultRows = new Vector<Vector<String>>();
       // Vector<Vector> results = new Vector<Vector>();
        //DefaultMutableTreeNode child = new DefaultMutableTreeNode (addThisActionObject);
        
        //addToThisNode.add( child);
        QueryResults query_results;
        if (actionParent.equals("editor_root")) {
            log.debug("createTreeNodes: "+ SettingsQueryFactory.Q_FETCH_PARENT_ACTIONS());
            query_results = instance.QueryResults(SettingsQueryFactory.Q_FETCH_PARENT_ACTIONS());
        } else {
            log.debug("createTreeNodes: "+SettingsQueryFactory.Q_FETCH_PARENT_ACTIONS(actionParent));
            query_results = instance.QueryResults(SettingsQueryFactory.Q_FETCH_PARENT_ACTIONS(actionParent));
        }
        //QueryResults query_results = instance.QueryResults(SettingsQueryFactory.Q_FETCH_CHILD_TOOLBAR_ACTIONS(actionParent));
        //QueryResults query_results = new QueryResults(results);
        if (query_results == null) 
            return ;
        
        if (query_results.hasResults() ) {
             HashMap columns = query_results.columnNameMap();
             //child actions are present
             //call the result nodes recursively...
             resultRows = query_results.theResults();
             //toolbarActionGroup grp = new toolbarActionGroup("create a section", "create a section");
                 for (int i = 0 ; i < resultRows.size(); i++ ) {
                   //get the results row by row into a string vector
                   Vector<java.lang.String> tableRow = new Vector<java.lang.String>();
                   tableRow = resultRows.elementAt(i);
                   toolbarAction action = new toolbarAction(tableRow, columns );
                   DefaultMutableTreeNode node = new DefaultMutableTreeNode(action);
                   rootNode.add(node);
                   if (recurse ) {
                       createTreeNodes(node, true);
                   }
               }
        }
        } catch (Exception ex) {
            log.error("Exception in createTreeNodes: " + ex.getMessage());
            ex.printStackTrace();
        }
      return ;
    }
    
    public void setOOComponentHandle(OOComponentHelper ooComponent) {
        System.out.println("Changing PANEL....");
        ooDocument = ooComponent;
    }

    public Component getObjectHandle() {
        return this;
    }

    public IEditorActionEvent getEventClass(toolbarAction action) {
        IEditorActionEvent event = EditorActionFactory.getEventClass(action);
        return event;
    }

    public IEditorActionEvent getEventClass(toolbarSubAction subAction) {
       IEditorActionEvent event = EditorActionFactory.getEventClass(subAction);
        return event;
    }
    
    public IEditorActionEvent getEventClass(ArrayList<String> action) {
       IEditorActionEvent event = EditorActionFactory.getEventClass(action);
        return event;
    }
    
    public void setParentWindowHandle(JFrame c) {
        this.parentFrame = c;
    }



    public JFrame getParentWindowHandle() {
        return this.parentFrame;
    }

   
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane generalEditorScrollPane;
    private javax.swing.JTree treeGeneralEditor;
    // End of variables declaration//GEN-END:variables
    
    /*
    class treePopupMenuAction extends AbstractAction {
        PopupTypeIdentifier treePopupMenuAction_popupType;
        
        public treePopupMenuAction (toolbarAction action) {
            super(action.toString());
            putValue("USER_OBJECT", action);
        }
        
        public treePopupMenuAction (String actionText,  toolbarAction action, PopupTypeIdentifier id ) {
            super(actionText);
            putValue("POPUP_IDENTIFIER", id);
            putValue("USER_OBJECT", action);
            treePopupMenuAction_popupType = id;
        }
     
        public treePopupMenuAction (String actionText,  toolbarSubAction action, PopupTypeIdentifier id ) {
            super(actionText);
            putValue("POPUP_IDENTIFIER", id);
            putValue("USER_OBJECT", action);
            treePopupMenuAction_popupType = id;
        }
     
        public treePopupMenuAction (String actionText,  String[] generalAction, PopupTypeIdentifier id ) {
            super(actionText);
            putValue("POPUP_IDENTIFIER", id);
            List<String> arList = Arrays.asList(generalAction);
            ArrayList<String> generalActionArray = new ArrayList<String>(arList);
            putValue("USER_OBJECT", generalActionArray);
            treePopupMenuAction_popupType = id;
        }
        
        
        public void actionPerformed(ActionEvent e) {
            //toolbarAction action = (toolbarAction) e.getSource();
            //System.out.println("action = " + action.toString());
               String s = ( "    Event source: " + e.getSource()
                  + "\n");
                log.debug("popup, actionPerforemd : "+ s);
               Object value = this.getValue("USER_OBJECT");
               Object popId = this.getValue("POPUP_IDENTIFIER");
               if (value == null ) {
                   log.debug("actionPerformed, popupmenu selection null value of object");
                   return;
               }
               if (value.getClass() == org.bungeni.editor.actions.toolbarAction.class ) {
                   toolbarAction action = (toolbarAction)value;
                   PopupTypeIdentifier popType = (PopupTypeIdentifier) popId;
                   processPopupSelection(action, popType);
               } 
               else if ( value.getClass() == org.bungeni.editor.actions.toolbarSubAction.class) {
                   toolbarSubAction subAction = (toolbarSubAction) value;
                   PopupTypeIdentifier popType= (PopupTypeIdentifier) popId;
                   processPopupSelection(subAction, popType);
               } else if (value.getClass() == java.util.ArrayList.class) {
                   ArrayList<String> arrGeneralAction = (ArrayList<String>) value;
                   PopupTypeIdentifier popType = (PopupTypeIdentifier) popId;
                   processPopupSelection(arrGeneralAction, popType);
               }
               if (value != null ) {
                   log.debug("popup, actionPerforemd : popupSelection");
               }
        }

        private SelectorDialogModes getDialogMode(){
          //warning text_select mode needs to be handled...
           if ( treePopupMenuAction_popupType == PopupTypeIdentifier.CREATE_EDIT) {
                    return SelectorDialogModes.TEXT_INSERTION;
           }
           if (treePopupMenuAction_popupType ==  PopupTypeIdentifier.EDIT){
                    return SelectorDialogModes.TEXT_EDIT;
           }
           if (treePopupMenuAction_popupType ==  PopupTypeIdentifier.SELECT_EDIT){
                    return SelectorDialogModes.TEXT_SELECTED_EDIT;
           }
           if (treePopupMenuAction_popupType ==  PopupTypeIdentifier.SELECT_INSERT){
                    return SelectorDialogModes.TEXT_SELECTED_INSERT;
           }
           if (treePopupMenuAction_popupType ==  PopupTypeIdentifier.APPLY_MARKUP){
                    return SelectorDialogModes.TEXT_SELECTED_INSERT;
           }
           if (treePopupMenuAction_popupType == PopupTypeIdentifier.SYSTEM_ACTION) {
                    return SelectorDialogModes.TEXT_SELECTED_SYSTEM_ACTION;
           }
           if (treePopupMenuAction_popupType == PopupTypeIdentifier.DOCUMENT_ACTION) {
                    return SelectorDialogModes.DOCUMENT_LEVEL_ACTION;
           }
           return SelectorDialogModes.NONE;
        }    
        
        private void processPopupSelection (toolbarAction action, PopupTypeIdentifier popId) {
            //{CREATE_EDIT , APPLY_MARKUP, EDIT, SELECT_INSERT, SELECT_EDIT  };
               if (popId == PopupTypeIdentifier.CREATE_EDIT) {
                   // toolbarAction action =(toolbarAction)thisNode.getUserObject();
                   // / * commented for issue 108 ***
                   // if (!ooDocument.isTextSelected())
                   //     action.setSelectorDialogMode(SelectorDialogModes.TEXT_INSERTION);
                   // else
                   //     action.setSelectorDialogMode(SelectorDialogModes.TEXT_SELECTED);
                   //
                    action.setSelectorDialogMode(this.getDialogMode());
                    IEditorActionEvent event = getEventClass(action);
                    event.doCommand(ooDocument, action, parentFrame);
              } else
               if (popId == PopupTypeIdentifier.EDIT) {
                    //look for existing masthead section 
                    //if it exists popup the edit screen for it.
                    //toolbarAction action =(toolbarAction)thisNode.getUserObject();
                    //we look for sections matching this action type.
                    action.setSelectorDialogMode(this.getDialogMode());
                    IEditorActionEvent event = getEventClass(action);
                    event.doCommand(ooDocument, action, parentFrame);
               } else 
              if (popId == PopupTypeIdentifier.APPLY_MARKUP) {
                    action.setSelectorDialogMode(this.getDialogMode());
                    IEditorActionEvent event = getEventClass(action);
                    event.doCommand(ooDocument, action, parentFrame);
              }
        }
        
        private void processPopupSelection (toolbarSubAction action, PopupTypeIdentifier popId) {
           
                action.setSelectorDialogMode(this.getDialogMode());
                IEditorActionEvent event = getEventClass(action);
                event.doCommand(ooDocument, action, parentFrame);

        }
        
        private void processPopupSelection(ArrayList<String> action, PopupTypeIdentifier popId) {
                IEditorActionEvent event = getEventClass(action);
                event.doCommand(ooDocument, action, parentFrame);
        }
        
        
 
    } */
    
    class treeGeneralEditorPaintTimerListener implements ActionListener{
        private JTree timedTree;
        
        public treeGeneralEditorPaintTimerListener(JTree timedTree){
            this.timedTree = timedTree;
        }
        
        public void actionPerformed(ActionEvent e) {
            if (timedTree.isShowing()) {
                this.timedTree.repaint();
            }
        }
        
    }

    class treeGeneralEditorWillExpandListener implements TreeWillExpandListener {
        public void treeWillExpand(TreeExpansionEvent event) throws ExpandVetoException {
            Object lastPathObject = event.getPath().getLastPathComponent();
            boolean throwException = false;
            if (lastPathObject.getClass() == org.bungeni.editor.toolbar.BungeniToolbarXMLAdapterNode.class) {
                        BungeniToolbarXMLAdapterNode adapterNode = (BungeniToolbarXMLAdapterNode) lastPathObject;
                        org.jdom.Attribute visibleAttrib = adapterNode.node.getAttribute("showChildren");
                        if (visibleAttrib == null) {
                            throwException = false;
                        } else {
                            if (visibleAttrib.getValue().equals("true")) {
                                throwException = false;
                            } else if (visibleAttrib.getValue().equals("conditional")) {
                                throwException = true;
                            } else if (visibleAttrib.getValue().equals("false")) {
                                throwException = true;
                            }
                        }
            }
            if (throwException) {
                throw new ExpandVetoException(event);
            }
        }

        public void treeWillCollapse(TreeExpansionEvent event) throws ExpandVetoException {
        }
        
    }
    
    class treeGeneralEditorMouseListener implements MouseListener {
      
        public void mouseClicked(MouseEvent evt) {
      
        }
        
  /*
       private void createPopupMenuItems(String[] arrGeneralAction) {
            popupMenu.removeAll();
            popupMenu.add(new treePopupMenuAction(popupMap.get(PopupTypeIdentifier.GENERAL_ACTION), arrGeneralAction, PopupTypeIdentifier.GENERAL_ACTION));
       }
    */   
      
        /*
        private void createPopupMenuItems(toolbarSubAction subAction) {
           // throw new UnsupportedOperationException("Not yet implemented");
            popupMenu.removeAll(); 
            if (subAction.action_type().equals("section_create"))  {
                popupMenu.add(new treePopupMenuAction(popupMap.get(PopupTypeIdentifier.SELECT_INSERT), subAction, PopupTypeIdentifier.SELECT_INSERT));
            } else if (subAction.action_type().equals("field_action")){
                 popupMenu.add(new treePopupMenuAction(popupMap.get(PopupTypeIdentifier.SELECT_INSERT), subAction, PopupTypeIdentifier.SELECT_INSERT));
                 popupMenu.add(new treePopupMenuAction(popupMap.get(PopupTypeIdentifier.SELECT_EDIT) , subAction, PopupTypeIdentifier.SELECT_INSERT));   
                 if (subAction.system_container().length() > 0 ) {
                     popupMenu.add(new treePopupMenuAction(popupMap.get(PopupTypeIdentifier.SYSTEM_ACTION), subAction, PopupTypeIdentifier.SYSTEM_ACTION));
                 }

            } else if (subAction.action_type().equals("document_action")) {

                popupMenu.add(new treePopupMenuAction(popupMap.get(PopupTypeIdentifier.DOCUMENT_ACTION), subAction, PopupTypeIdentifier.DOCUMENT_ACTION));

            } else if (subAction.action_type().equals("markup")) {
                popupMenu.removeAll();
                popupMenu.add(new treePopupMenuAction(popupMap.get(PopupTypeIdentifier.APPLY_MARKUP), subAction, PopupTypeIdentifier.APPLY_MARKUP));
            }
        } 
        */
        
        /*
       private void createPopupMenuItems (toolbarAction baseNodeAction){
           //do not generate menu for top level actions 
           if (baseNodeAction.isTopLevelAction()) return ;
            
            if (baseNodeAction.action_type().equals("section")) {
                popupMenu.removeAll();
                //popupMenu.add(new treePopupMenuAction(popup_section_actions[0], baseNodeAction, PopupTypeIdentifier.VIEW_ACTIONS));
                popupMenu.add(new treePopupMenuAction(popupMap.get(PopupTypeIdentifier.CREATE_EDIT), baseNodeAction, PopupTypeIdentifier.CREATE_EDIT));
                if (baseNodeAction.action_edit_dlg_allowed() == 1)
                    popupMenu.add(new treePopupMenuAction(popupMap.get(PopupTypeIdentifier.EDIT), baseNodeAction, PopupTypeIdentifier.EDIT));
                //popupMenu.add(new treePopupMenuAction(popup_section_actions[2]))
            } else 
            if (baseNodeAction.action_type().equals("markup")) {
                popupMenu.removeAll();
                popupMenu.add(new treePopupMenuAction(popupMap.get(PopupTypeIdentifier.APPLY_MARKUP), baseNodeAction, PopupTypeIdentifier.APPLY_MARKUP));
            }
         }
       */
        
       public void mousePressed(MouseEvent evt) {
            //get treepath for currennt mouse click
            TreePath selPath = treeGeneralEditor.getPathForLocation(evt.getX(), evt.getY());
            if (selPath != null ) {
                Object node = selPath.getLastPathComponent();
                if (node == null ) return;
                if (node.getClass() == org.bungeni.editor.toolbar.BungeniToolbarXMLAdapterNode.class ) {
                    BungeniToolbarXMLAdapterNode toolbarXmlNode = (BungeniToolbarXMLAdapterNode) node;
                    if (toolbarXmlNode.childCount() == 0 && evt.getClickCount() == 2) {
                        processBungeniToolbarXmlAdapterNode(toolbarXmlNode); 
                    }
                }  
            }
       }
       private void processAction(toolbarAction action) {
           log.debug("processAction:" + action.action_name() );

           if (action.isTopLevelAction()) {
               log.info("toolbar: processAction: not processing topLevelAction type");
               return;
           }
          IEditorActionEvent event = getEventClass(action);
          event.doCommand(ooDocument, action, parentFrame);
       }
       
       private void processSubAction(toolbarSubAction action) {
           log.debug("processSubAction:" + action.sub_action_name() );
                   
              IEditorActionEvent event = getEventClass(action);
              event.doCommand(ooDocument, action, parentFrame);
       }
       
       private void processBungeniToolbarXmlAdapterNode (BungeniToolbarXMLAdapterNode adapterNode) {
              try {
              BungeniToolbarXMLTreeNodeProcessor nodeProc = new BungeniToolbarXMLTreeNodeProcessor(adapterNode);
              Object nodeUserObject = adapterNode.getUserObject();
                   //check if node is enabled or disabled
                   if (nodeUserObject != null) {
                       if (nodeUserObject.getClass() == treeGeneralEditorNodeState.class) {
                           treeGeneralEditorNodeState thestate = (treeGeneralEditorNodeState)nodeUserObject;
                           //if disabled, dont process, just return
                           if (thestate == treeGeneralEditorNodeState.DISABLED) {
                               log.debug("treeGeneralEditor, mousclick, node state was disabled ");
                             return;  
                           } 
                       }
                   }
                   //blank target, so nothing to process, return
                   if (nodeProc.getTarget() == null ){
                       log.debug("treeGeneralEditor, mousclick, target was null");
                       return;
                   } 
                   //if node is not visible, nothing to process, return
                   if (nodeProc.getVisible() == null ) {
                       return;
                   }
                   //based on the target information we need to create the action objectr
                   
                   String strTarget = nodeProc.getTarget();
                   log.info("processBungeniToolbarXmlAdapterNode  target = " + strTarget);
                   BungeniToolbarTargetProcessor targetObj = new BungeniToolbarTargetProcessor(strTarget);
                   SelectorDialogModes selectedMode = SelectorDialogModes.valueOf(nodeProc.getMode());
                   toolbarAction tbAction = null;
                   toolbarSubAction tbSubAction = null;
                   switch (targetObj.target_type) {
                       case ACTION:
                          tbAction =  processInsertion(targetObj);
                          tbAction.setSelectorDialogMode(selectedMode);
                          processAction (tbAction);
                          break;
                       case SUB_ACTION:
                          tbSubAction =  processSelection(targetObj); 
                          tbSubAction.setSelectorDialogMode(selectedMode);
                          processSubAction(tbSubAction);
                          break;
                   } 
                   /*
                   switch (targetObj.target_type) {
                       case GENERAL_ACTION :
                            createPopupMenuItems(targetObj.strTarget);
                            //popupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
                            break;
                       case ACTION :
                           if (nodeProc.getMode().equals("TEXT_INSERTION")) {
                                tbAction =  processInsertion(targetObj);
                               createPopupMenuItems(tbAction);
                              // popupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
                           }
                            break;
                       case SUB_ACTION :
                           if (nodeProc.getMode().equals("TEXT_SELECTED_INSERT")) {
                               tbSubAction = processSelection(targetObj); 
                                createPopupMenuItems(tbSubAction);
                                //popupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
                           }
                            break;
                   } */
                   /*
                   if (targetObj.target_type == BungeniToolbarTargetProcessor.TARGET.GENERAL_ACTION) {
                        createPopupMenuItems(arrTargetObj);
                        popupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
                   } else if ((actionType.equals("toolbarAction")) || (actionType.equals("toolbarSubAction"))) {
                       toolbarAction tbAction = null;
                       toolbarSubAction tbSubAction = null;
                       // arrTargetObj[0] is the action class, arrTargetObj[1] is the action class identifier
                       if (nodeProc.getMode().equals("TEXT_INSERTION")) {
                            tbAction =  processInsertion(arrTargetObj);
                       } else if (nodeProc.getMode().equals("TEXT_SELECTED_INSERT")) {
                            tbSubAction =  processSelection(arrTargetObj);
                       }
                       if (tbAction != null) {
                           createPopupMenuItems(tbAction);
                           popupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
                       }
                       if (tbSubAction != null) {
                           createPopupMenuItems(tbSubAction);
                           popupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
                       }
                   } */
                   
                } catch (Exception ex) {
                    log.error("processBungeniToolbarXmlAdapterNode:"+ ex.getMessage());
                    log.error("processBungeniToolbarXmlAdapterNode:"+ CommonExceptionUtils.getStackTrace(ex));
                }
           
       }
       
       /**** Commented for acion migration **** 
       public void mousePressed(MouseEvent evt) {
                
                //we dont want to process right click
                if (SwingUtilities.isRightMouseButton(evt)) {
                    log.debug("mousePressed: Ignore right clicks");
                    return;
                }
                //get selected row
                int selRow = treeGeneralEditor.getRowForLocation(evt.getX(), evt.getY());
                //get treepath for currennt mouse click
                TreePath selPath = treeGeneralEditor.getPathForLocation(evt.getX(), evt.getY());
                if (selRow == -1 ) return ; //dont process invalid clicks on tree nodes
                //get the tree node and filter on userObject() 
               Object pathComponent =  selPath.getLastPathComponent();
               //process clicks only when the node object component is a bungenitoolbarxmladapternode
               if (pathComponent.getClass() == org.bungeni.editor.toolbar.BungeniToolbarXMLAdapterNode.class) {
                    processBungeniToolbarXmlAdapterNode(evt, pathComponent);
               }
        }
        */
       /*
       private void processBungeniToolbarXmlAdapterNode(MouseEvent evt, Object pathComponent){
                try {
                   BungeniToolbarXMLAdapterNode thenode = (BungeniToolbarXMLAdapterNode)pathComponent;
                   BungeniToolbarXMLTreeNodeProcessor nodeProc = new BungeniToolbarXMLTreeNodeProcessor(thenode);
                   Object nodeUserObject = thenode.getUserObject();
                   //check if node is enabled or disabled
                   if (nodeUserObject != null) {
                       if (nodeUserObject.getClass() == treeGeneralEditorNodeState.class) {
                           treeGeneralEditorNodeState thestate = (treeGeneralEditorNodeState)nodeUserObject;
                           //if disabled, dont process, just return
                           if (thestate == treeGeneralEditorNodeState.DISABLED) {
                             return;  
                           } 
                       }
                   }
                   //blank target, so nothing to process, return
                   if (nodeProc.getTarget() == null ){
                       log.debug("treeGeneralEditor, mousclick, target was null");
                       return;
                   } 
                   //if node is disabled, nothing to process, return
                   if (nodeProc.getVisible() == null ) {
                       return;
                   }
                   //based on the target information we need to create the action objectr
                   
                   String strTarget = nodeProc.getTarget();
                   log.info("target = " + strTarget);
                   BungeniToolbarTargetProcessor targetObj = new BungeniToolbarTargetProcessor(strTarget);
                   
          //         String[] arrTargetObj = strTarget.split("[.]");
            //       String actionType = arrTargetObj[0];
                    toolbarAction tbAction = null;
                    toolbarSubAction tbSubAction = null;
                    
                   switch (targetObj.target_type) {
                       case GENERAL_ACTION :
                            createPopupMenuItems(targetObj.strTarget);
                            popupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
                            break;
                       case ACTION :
                           if (nodeProc.getMode().equals("TEXT_INSERTION")) {
                                tbAction =  processInsertion(targetObj);
                               createPopupMenuItems(tbAction);
                               popupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
                           }
                            break;
                       case SUB_ACTION :
                           if (nodeProc.getMode().equals("TEXT_SELECTED_INSERT")) {
                               tbSubAction = processSelection(targetObj); 
                                createPopupMenuItems(tbSubAction);
                                popupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
                           }
                            break;
                   }
                   
                } catch (Exception ex) {
                    log.error("processBungeniToolbarXmlAdapterNode:"+ ex.getMessage());
                    log.error("processBungeniToolbarXmlAdapterNode:"+ CommonExceptionUtils.getStackTrace(ex));
                }
       }
*/       
      // private void processGeneralAction(String[] )
       private toolbarSubAction processSelection(BungeniToolbarTargetProcessor targetObj) {
         
            String documentType = BungeniEditorProperties.getEditorProperty("activeDocumentMode");
            instance.Connect();
            String actionQuery = SettingsQueryFactory.Q_FETCH_SUB_ACTIONS(documentType, targetObj.actionName, targetObj.subActionName);
            log.info("processSelection: "+ actionQuery); 
            QueryResults qr = instance.QueryResults(actionQuery);
             instance.EndConnect();
             if (qr == null ) {
                 log.info("processSelection : queryResults :" + actionQuery + " were null, metadata incorrectly setup");
                 return null;
             }
             if (qr.hasResults()) {
                //this should return only a single toolbarSubAction
                 toolbarSubAction subActionObj =  new toolbarSubAction(qr.theResults().elementAt(0), qr.columnNameMap());
                 subActionObj.setActionValue(targetObj.actionValue);
                 return subActionObj;
             } else {
                  log.info("processSelection : queryResults :" + actionQuery + " were null, metadata incorrectly setup");
                 return null;
             }
       }
       private toolbarAction processInsertion(BungeniToolbarTargetProcessor targetAction) {
          // BungeniToolbarTargetProcessor targetObject = new BungeniToolbarTargetProcessor()
            String documentType = BungeniEditorProperties.getEditorProperty("activeDocumentMode");
          
           /*
           int actionLength =  targetAction.length;
            String actionType = targetAction[0];
             String actionMainAction = targetAction[1];
            String actionSubAction = "";
            String actionSubActionValue="";
            if (actionLength == 3) {
                //actiontype.parentaciton.sub_aciton_name:sub_action_value
                //the below will give us sub_action_name:sub_action_value
                if (targetAction[2].indexOf(":") != -1) {
                  String[] actionSubActionSplit = targetAction[2].split(":")  ;
                  actionSubAction = actionSubActionSplit[0];
                  actionSubActionValue = actionSubActionSplit[1];
                } else
                actionSubAction = targetAction[2];
            } */
           
           instance.Connect();
           String actionQuery = SettingsQueryFactory.Q_FETCH_ACTION_BY_NAME(documentType, targetAction.actionName);
           QueryResults qr = instance.QueryResults(SettingsQueryFactory.Q_FETCH_ACTION_BY_NAME(documentType, targetAction.actionName));
             instance.EndConnect();
             if (qr == null ) {
                 log.info("toolbar: processInsertion: the metadata has been setup incorrectly for action :" + targetAction.actionName);
                 return null;
             }
             if (qr.hasResults()) {
                 return new toolbarAction(qr.theResults().elementAt(0), qr.columnNameMap());
             } else {
                 log.info("toolbar: processInsertion: the metadata has been setup incorrectly for action :" + targetAction.actionName);
                 return null;
             }
       }
       
       /*
       public void mousePressed(MouseEvent evt) {
         
                //we dont want to process right click
                if (SwingUtilities.isRightMouseButton(evt)) {
                    log.debug("mousePressed: Ignore right clicks");
                    return;
                }
                
                int selRow = treeGeneralEditor.getRowForLocation(evt.getX(), evt.getY());
                
                TreePath selPath = treeGeneralEditor.getPathForLocation(evt.getX(), evt.getY());
                if (selRow == -1 ) return ; //dont process invalid clicks on tree nodes
                //get the tree node and filter on userObject() 
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) selPath.getLastPathComponent();
                Object obj = node.getUserObject();
                if (obj.getClass() == org.bungeni.editor.actions.toolbarSubAction.class ) {
                         toolbarSubAction subAction = null;
                           subAction = (toolbarSubAction) obj; 
                           if (subAction != null ) {
                               createPopupMenuItems(subAction);
                               popupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
                           }
                } else 
                if (obj.getClass() == org.bungeni.editor.actions.toolbarAction.class ) {
                        toolbarAction action = null;
                        action = (toolbarAction) obj;
                        if (action != null) {
                            if (!action.isTopLevelAction()) {
                                createPopupMenuItems (action);
                                popupMenu.show(evt.getComponent(), evt.getX(), evt.getY());
                            }
                        }       
                } 
        }
        */
       
        public void mouseReleased(MouseEvent e) {
        }

        public void mouseEntered(MouseEvent e) {
        }

        public void mouseExited(MouseEvent e) {
        }

      
        
    }

    
    /*Static declarations used by toolbar classes */
    static HashMap<String, toolbarIcon> toolbarIconMap = new HashMap<String,toolbarIcon>();
    static int BLOCK_ICON = 0, METADATA_ICON = 1, ACTION_ICON = 2;
    static String[] icons = { "block", "block_action", "metadata", "action"};
       
    class toolbarIcon {
            public String iconName;
            public ImageIcon enabledIcon;
            public ImageIcon disabledIcon;
            public toolbarIcon(String icon, String pathPrefix) {
                   String imgPathEnabled = pathPrefix + icon + "_enabled.png" ;
                   String imgPathDisabled = pathPrefix + icon +"_disabled.png" ;
                   enabledIcon = new ImageIcon(getClass().getResource(imgPathEnabled), "");
                   disabledIcon = new ImageIcon(getClass().getResource(imgPathDisabled), "");
            }
    
    }
         
    enum treeGeneralEditorNodeState {ENABLED, DISABLED};
    /*** caches conditionValue and condition processor for better performance **/
    HashMap<String, BungeniToolbarConditionProcessor> conditionMap = new HashMap<String, BungeniToolbarConditionProcessor>();
    class treeGeneralEditorCellRenderer extends JLabel implements TreeCellRenderer {

         int SECTION_ICON = 0;
         int SECTION_PLUS_ICON = 1;
         int MARKUP_ICON = 2;
         int TOPLEVEL_ICON=3;
         int DISABLED_ICON=4;
         Font labelFont = new Font("Tahoma", Font.PLAIN, 11);
         public treeGeneralEditorCellRenderer() {
            if (toolbarIconMap.size() == 0 ) {
                for (int i=0; i < icons.length; i++ ) {
                    toolbarIconMap.put(icons[i], new toolbarIcon(icons[i], "/gui/"));
                }
            }
         }
        private int ACTION_OBJECT=0, SELECTION_OBJECT=1;
        
        public void setToolbarStates() {
            
        }
        
        
        private toolbarIcon getIcon(String elementName ) {
            if (elementName.equals("root")) {
                return toolbarIconMap.get("block");
            } else if (elementName.equals("actionGroup")) {
                return toolbarIconMap.get("block");
            } else if (elementName.equals("blockAction")) {
                return toolbarIconMap.get("block_action");
            } else if (elementName.equals("action")) {
                return toolbarIconMap.get("action");
            } else if (elementName.equals("subaction")) {
                return toolbarIconMap.get("action");
            } else
                return toolbarIconMap.get("block");
        }
        
        
        public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {
                int objectType = -1;
                toolbarIcon currentIcon;
                Object userObj;
                if (ooDocument == null) {
                    return this;
                }
                try {
                   if (selected) 
                      setOpaque(true);
                   else
                      setOpaque(false);
                
                    //for selection object the node user object is always a string
                    //if (userObj.getClass() == java.lang.String.class) 
                    //     objectType = this.SELECTION_OBJECT;
                    if (value.getClass() == org.bungeni.editor.toolbar.BungeniToolbarXMLAdapterNode.class) {
                        BungeniToolbarXMLAdapterNode toolbarNode = (BungeniToolbarXMLAdapterNode)value;
                        BungeniToolbarXMLTreeNodeProcessor nodeProc = new BungeniToolbarXMLTreeNodeProcessor(toolbarNode);
                        toolbarIcon theIcon = getIcon(toolbarNode.node.getName());
                        org.jdom.Attribute visibleAttrib = toolbarNode.node.getAttribute("visible");
                        org.jdom.Attribute conditionAttrib = toolbarNode.node.getAttribute("condition");
                        org.jdom.Attribute nameAttrib = toolbarNode.node.getAttribute("name");
                        setFont(labelFont);
                        //if visible = false - disable the action
                        //if visible = true  - check if condition is required
                        //if condition = none - enable the action unconditionallhy
                        //if condition = something - check if the condition is valid
                        //enable the aciton only when the condition is valid
                        if (visibleAttrib == null) {
                           nodeEnabled(theIcon, nodeProc);
                        } else
                        if (visibleAttrib.getValue().equals("false")) {
                            nodeDisabled(theIcon, nodeProc);
                        } else
                        if (visibleAttrib.getValue().equals("true")) {
                            if (conditionAttrib == null ) {
                                //no condition act as if true
                                nodeEnabled(theIcon, nodeProc);
                            } else if (conditionAttrib.getValue().equals("none")) {
                                //no condition act as if true
                                nodeEnabled(theIcon, nodeProc);
                            } else if (conditionAttrib.getValue().length()> 0) {
                                //other condition always evaluates to whether action should be enabeld or disabled
                                boolean bCondition =  processActionCondition(conditionAttrib);
                               if (bCondition) {
                                   nodeEnabled(theIcon, nodeProc);
                               } else {
                                   nodeDisabled(theIcon, nodeProc);
                               }
                            }
                        }                    
                    
                    }
                
                } catch (Exception ex) {
                    log.error("cellRender error: " + ex.getMessage());
                    log.error("cellRender stackTrace: "+ org.bungeni.ooo.utils.CommonExceptionUtils.getStackTrace(ex));
                } finally {
                return this;
                }
        }

        void nodeEnabled(toolbarIcon theIcon, BungeniToolbarXMLTreeNodeProcessor nodeProc) {
            nodeProc.getAdapterNode().setUserObject(treeGeneralEditorNodeState.ENABLED);
            String ttText = nodeProc.getToolTip();
            if (ttText != null) {
               setToolTipText(ttText.replace('\n','-'));
            }
            setForeground(new java.awt.Color(0x00, 0x00,0x00));
      
            setIcon(theIcon.enabledIcon);
            setText(nodeProc.getTitle());
           // treeGeneralEditor.getModel().valueForPathChanged()
            //this.repaint();
            //tree.repaint();
        }
        
        
        void nodeDisabled(toolbarIcon theIcon, BungeniToolbarXMLTreeNodeProcessor nodeProc) {
            nodeProc.getAdapterNode().setUserObject(treeGeneralEditorNodeState.DISABLED);
            String ttText = nodeProc.getToolTip();
            if (ttText != null) {
                setToolTipText(ttText.replace('\n','-'));
            }
            setForeground(new java.awt.Color(0xFF, 0xCC,0xFF));
            setIcon(theIcon.disabledIcon);
            setText(nodeProc.getTitle());
                //this.repaint();
            //tree.repaint();
        }
       
         boolean processActionCondition(org.jdom.Attribute conditionAttrib) {
            boolean bAction = true;

            String conditionValue =  conditionAttrib.getValue().trim();
            if (!conditionMap.containsKey(conditionValue)) {
                //already has conditionprocessor object, get cached object and reset...
                //conditionMap.get(conditionValue).setOOComponentHandle(ooDocument);
            //} else {
                BungeniToolbarConditionProcessor condProc = new BungeniToolbarConditionProcessor(conditionValue);
                conditionMap.put(conditionValue, condProc);
            }
            //BungeniToolbarConditionProcessor condProc = new BungeniToolbarConditionProcessor(ooDocument, conditionValue);
            bAction = conditionMap.get(conditionValue).evaluate(ooDocument);
            //condProc.evaluate();
            /*
            //first split multiple conditions by -and- or -or- 
            //second evaluate each condition for validity
            if (conditionValue.indexOf(" and ") != -1) {
               bAction =  processCondition_and_Condition(conditionValue);
            } else if (conditionValue.indexOf(" or ") != -1) {
               bAction =  processCondition_or_Condition(conditionValue);
            } else {
                //no conditionals in the action conditionValue, process it as a singular action
               bAction = processSubCondition(conditionValue);
            }
             */
            return bAction;
        }

  
     
     /****
     *
class treeGeneralEditorCellRenderer extends JLabel implements TreeCellRenderer {
        
        ImageIcon[] imgIcons;
         int SECTION_ICON = 0;
         int SECTION_PLUS_ICON = 1;
         int MARKUP_ICON = 2;
         int TOPLEVEL_ICON=3;
        String[] icons = { "action_m.png", "action_m_plus.png", "action_s.png", "icon_17x20.png" };
        
        public treeGeneralEditorCellRenderer() {
              imgIcons = new ImageIcon[icons.length];
              for (int i=0; i < imgIcons.length ; i++) {
                  String imgPath = "/gui/" + icons[i] ;
                    URL imgUrl = null;
                  imgUrl = getClass().getResource(imgPath);
                  imgIcons[i] = new ImageIcon(imgUrl, "");
              }
        }
        private int ACTION_OBJECT=0, SELECTION_OBJECT=1;
        
        public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {
                int objectType = -1;
                try {
                    if (selected) 
                      setOpaque(true);
                    else
                      setOpaque(false);
               
                    Object userObj;
                    //only if its a defaultmutabletreenode
                    if (!(value instanceof DefaultMutableTreeNode)) {
                        log.debug("renderTreeComponent: not a defaultMutabletreenode");
                        return this;
                    }
                    DefaultMutableTreeNode uo = (DefaultMutableTreeNode)value;
                    //first check the object type
                    userObj = uo.getUserObject();
                    //for selection object the node user object is always a string
                    //if (userObj.getClass() == java.lang.String.class) 
                    //     objectType = this.SELECTION_OBJECT;
                    if (userObj.getClass() == org.bungeni.editor.actions.toolbarSubAction.class) 
                         objectType = this.SELECTION_OBJECT;
                    else if (userObj.getClass() == org.bungeni.editor.actions.toolbarAction.class) 
                         objectType = this.ACTION_OBJECT;
                  
                  
                    if (objectType == -1 ) {
                      log.debug("getTreeCellRenderComponent exception");
                      return this;
                    }
                    // if (uo.isLeaf()) {
                    if (this.SELECTION_OBJECT == objectType) {
                          log.debug("treeCellRenderer: user Object is a string... ");
                          setIcon(null);
                          toolbarSubAction subAction = (toolbarSubAction)userObj;
                          log.debug("treeCellRenderer: " + subAction.toString());
                          setText(" "+ subAction.action_display_text());
                        // return this;
                    } else if (this.ACTION_OBJECT == objectType) {
                          toolbarAction act = (toolbarAction) userObj;
                          //just to make sure a null object is not returned
                          if (act == null ) { 
                              log.debug("treeCellRenderer: action object is null");  
                              return this;
                          } 
                          setText(act.action_display_text());
                          //action_type is not valid for the invisibleRoot, editorRoot or the selectionRoot
                          //we need to filter by action name
                          if (act.isTopLevelAction() ) {
                                setIcon(imgIcons[TOPLEVEL_ICON]);
                          } else {
                              if (act.action_type().equals("markup")) 
                                setIcon(imgIcons[MARKUP_ICON]);
                              else 
                                setIcon(imgIcons[SECTION_ICON]);
                          }
                    }       
                  //} else {
                  //    setIcon(imgIcons[SECTION_PLUS_ICON]);
                  //}
                
                
                } catch (Exception ex) {
                    log.error("cellRender error: " + ex.getMessage());
                    log.error("cellRender stackTrace: "+ org.bungeni.ooo.utils.CommonExceptionUtils.getStackTrace(ex));
                } finally {
                return this;
                }
    } */   
        

       }        

}
