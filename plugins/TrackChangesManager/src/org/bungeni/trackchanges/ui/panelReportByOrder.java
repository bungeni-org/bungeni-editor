package org.bungeni.trackchanges.ui;

import java.awt.Color;
import java.awt.Component;
import java.util.Iterator;
import java.util.Vector;
import java.util.concurrent.ExecutionException;
import javax.swing.JFrame;
import javax.swing.JTree;
import javax.swing.SwingWorker;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import net.java.swingfx.waitwithstyle.PerformanceInfiniteProgressPanel;
import org.bungeni.db.BungeniClientDB;
import org.bungeni.db.QueryResults;
import org.bungeni.odfdocument.report.IBungeniOdfDocumentReportProcess;
import org.bungeni.odfdocument.report.IBungeniOdfDocumentReportUI;
import org.bungeni.odfdom.document.BungeniOdfDocumentHelper;
import org.bungeni.reports.process.reportEditableChangesByOrder_Queries;
import org.bungeni.trackchanges.utils.CommonFunctions;

/**
 *
 * @author Ashok Hariharan
 */
public class panelReportByOrder extends panelChangesBase implements IBungeniOdfDocumentReportUI {
    private static org.apache.log4j.Logger log            =
        org.apache.log4j.Logger.getLogger(panelReportByOrder.class.getName());
    public static JFrame                   thisFrame = null;
    private IBungeniOdfDocumentReportProcess reportProcess = null;
    private BungeniOdfDocumentHelper[] reportInputDocuments;
    
    /** Creates new form panelReportByOrder */
    public panelReportByOrder() {
        super();
        initComponents();
    }

      public panelReportByOrder(JFrame parentFrm, String pName) {
           super(parentFrm, pName);
           initComponents();
     }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        btnMoveUp = new javax.swing.JButton();
        btnMoveDown = new javax.swing.JButton();
        btnFinish = new javax.swing.JButton();
        splitPane = new javax.swing.JSplitPane();
        scrollReport = new javax.swing.JScrollPane();
        treeReportByOrder = new javax.swing.JTree();
        scrollPane = new javax.swing.JScrollPane();
        treeContentPane = new javax.swing.JTextPane();

        btnMoveUp.setFont(new java.awt.Font("DejaVu Sans", 0, 10));
        btnMoveUp.setText("Move UP");

        btnMoveDown.setFont(new java.awt.Font("DejaVu Sans", 0, 10));
        btnMoveDown.setText("Move DOWN");

        btnFinish.setFont(new java.awt.Font("DejaVu Sans", 0, 10));
        btnFinish.setText("Finish");

        splitPane.setDividerLocation(350);
        splitPane.setDividerSize(3);

        treeReportByOrder.setFont(new java.awt.Font("DejaVu Sans", 0, 10)); // NOI18N
        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("Loading...");
        treeReportByOrder.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        scrollReport.setViewportView(treeReportByOrder);

        splitPane.setLeftComponent(scrollReport);

        treeContentPane.setEditable(false);
        treeContentPane.setFont(new java.awt.Font("DejaVu Sans", 0, 10)); // NOI18N
        scrollPane.setViewportView(treeContentPane);

        splitPane.setRightComponent(scrollPane);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(btnMoveUp, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnMoveDown)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnFinish, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(250, Short.MAX_VALUE))
            .addComponent(splitPane, javax.swing.GroupLayout.DEFAULT_SIZE, 463, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(splitPane, javax.swing.GroupLayout.DEFAULT_SIZE, 280, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnMoveUp)
                    .addComponent(btnMoveDown)
                    .addComponent(btnFinish)))
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnFinish;
    private javax.swing.JButton btnMoveDown;
    private javax.swing.JButton btnMoveUp;
    private javax.swing.JScrollPane scrollPane;
    private javax.swing.JScrollPane scrollReport;
    private javax.swing.JSplitPane splitPane;
    private javax.swing.JTextPane treeContentPane;
    private javax.swing.JTree treeReportByOrder;
    // End of variables declaration//GEN-END:variables

    private void initialize() {
        PANEL_FILTER_REVIEW_STAGE = "ClerkConsolidationReview";
        PANEL_REVIEW_STAGE        = "";
       // loadFilesFromFolder();
        init_Tree();
    }

    private void init_Tree(){
        startProgress();
        loadTreeWorker treeLoader = new loadTreeWorker();
        treeLoader.execute();
        this.treeContentPane.setContentType("text/html");
        this.treeReportByOrder.addTreeSelectionListener(new treeReportByOrderSelectionListener());
    }

    class treeReportByOrderSelectionListener implements TreeSelectionListener {


          public treeReportByOrderSelectionListener(){
          }

          public void valueChanged(TreeSelectionEvent tse) {
                  DefaultMutableTreeNode node = (DefaultMutableTreeNode)
                       treeReportByOrder.getLastSelectedPathComponent();
                  if (node == null) {
                    //Nothing is selected.
                    return;
                  }
                  GroupedChange gc = (GroupedChange) node.getUserObject();
                  if (gc.getObjType() == GroupedChange.OBJECT_TYPE.CHANGE) {
                      String changeText = gc.getDocumentChange().getChangeText();
                      String changeType = gc.getDocumentChange().getChangeType();
                      if (changeType.equals("insertion")) {
                        treeContentPane.setText(getInsertStyle(changeText));
                      } else {
                        treeContentPane.setText(getDeleteStyle(changeText));
                      }
                  }
         }

          private String getInsertStyle (String text) {
              return "<html><span style='color:blue;'>" + text.replace("\n", "<br />") + "</span></html>";
          }

          private String getDeleteStyle (String text) {
              return "<html><s style='color:red;'>" + text.replace("\n", "<br />")  + "</s></html>";
          }

    }

    class loadTreeWorker extends SwingWorker {

        @Override
        protected Object doInBackground() throws Exception {
                getProcessHook().prepareProcess(reportInputDocuments);
                return Boolean.TRUE;
        }

        @Override
        protected void done(){
                try {
                    Boolean bProcessDocs = (Boolean) get();
                    if (bProcessDocs == true ) 
                        loadTree();
                    else
                        log.error("loadTreeWorker : prepare process returned FALSE");
                    stopProgress();
                    for (int i = 0; i < treeReportByOrder.getRowCount(); i++) {
                            treeReportByOrder.expandRow(i);
                       }
                } catch (InterruptedException ex) {
                    log.error("Error while loading tree ", ex);
                } catch (ExecutionException ex) {
                    log.error("Error while loading tree ", ex);
                }
        }

        private void loadTree(){
            DefaultMutableTreeNode dmtRoot = null;
            String query = reportEditableChangesByOrder_Queries.GET_ROOT_SECTION_HIERARCHY(CommonFunctions.getCurrentBillID());
            BungeniClientDB db = BungeniClientDB.defaultConnect();
            QueryResults qr = db.ConnectAndQuery(query);
            if (qr.hasResults()) {
                Vector<Vector<String>> results = qr.theResults();
                for (Vector<String> aRow : results) {
                    String rootSecId = qr.getField(aRow, "SECTION_ID");
                    String rootSecName = qr.getField(aRow, "SECTION_NAME");
                    String rootSecType = qr.getField(aRow, "SECTION_TYPE");
                    GroupedChange gc = new GroupedChange("root", "bill", rootSecId);
                    dmtRoot = new DefaultMutableTreeNode(gc);
                    //now look for all changes in the root section
                    /*
                    qr = db.ConnectAndQuery(reportEditableChangesByOrder_Queries.GET_CHANGES_BY_GROUP_IN_DOC_ORDER(CommonFunctions.getCurrentBillID(),
                               rootSecId));

                    if (qr.hasResults()) {
                        //add change nodes
                        qr.theResults();

                    }

                    //query child sections
                    */
                    processSubTreeHiearchy (db, CommonFunctions.getCurrentBillID(), dmtRoot, rootSecName, rootSecType, rootSecId );

                    }

                }
            if (dmtRoot != null) {
              DefaultTreeModel treeModel = new DefaultTreeModel(dmtRoot);
              treeReportByOrder.setCellRenderer(new reportCellRenderer());
              treeReportByOrder.setModel(treeModel);
            }
            }

        }

        private void processSubTreeHiearchy (BungeniClientDB db, String billId, DefaultMutableTreeNode dmtParent, String baseSecName, String baseSecType, String baseSecId  ) {

                QueryResults qr = db.ConnectAndQuery(reportEditableChangesByOrder_Queries.GET_CHANGES_BY_GROUP_IN_DOC_ORDER(CommonFunctions.getCurrentBillID(),
                               baseSecId));

                    if (qr.hasResults()) {
                        //add change nodes for this section
                        Vector<Vector<String>> results = qr.theResults();
                        for (Vector<String> aRow : results) {
                            DocumentChange docChange = new DocumentChange(
                            qr.getField(aRow, "DOC_NAME"),
                            qr.getField(aRow, "CHANGE_ID"),
                            qr.getField(aRow, "CHANGE_TYPE"),
                            qr.getField(aRow, "PATH_START"),
                            qr.getField(aRow, "PATH_END"),
                            qr.getField(aRow, "ORDER_IN_DOC"),
                            qr.getField(aRow, "OWNER") ,
                            qr.getField(aRow, "CHANGE_DATE") ,
                            qr.getField(aRow, "CHANGE_TEXT") ,
                            Integer.parseInt(qr.getField(aRow, "ORDER_WEIGHT").toString())
                                    );
                            GroupedChange groupedChange = new GroupedChange (baseSecName, baseSecType, baseSecId,  docChange);
                            DefaultMutableTreeNode dmtThis = new DefaultMutableTreeNode(groupedChange);
                            dmtParent.add(dmtThis);
                        }
                    }

                    //query child sections
                qr = db.ConnectAndQuery(reportEditableChangesByOrder_Queries.GET_SECTION_HIERARCHY(
                            CommonFunctions.getCurrentBillID(),
                            baseSecId
                            ));
                 if (qr.hasResults()) {
                     Vector<Vector<String>> results = qr.theResults();
                     for (Vector<String> aRow : results) {
                         String secId = qr.getField(aRow, "SECTION_ID");
                         String secName = qr.getField(aRow, "SECTION_NAME");
                         String secType  = qr.getField(aRow, "SECTION_TYPE");
                         GroupedChange gc = new GroupedChange(secName, secType, secId);
                         DefaultMutableTreeNode dmtSec = new DefaultMutableTreeNode(gc);
                         processSubTreeHiearchy(db, billId, dmtSec, secName, secType, secId);
                         dmtParent.add(dmtSec);
                     }
                 }


       }

        /*
        private void loadTree(){
            //the tree is loaded here
            DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(new GroupedChange("root", "bill"));
            String groupedQuery = reportEditableChangesByOrder_Queries.GET_CHANGE_GROUPS_BILL_BY_MANUAL_ORDER(CommonFunctions.getCurrentBillID());
            log.info ("loadTree : groupedQuery = " + groupedQuery);
            BungeniClientDB db = BungeniClientDB.defaultConnect();
            QueryResults qr = db.ConnectAndQuery(groupedQuery);
            String[] colgroupBy = qr.getSingleColumnResult("GROUP_BY");
            colgroupBy = CommonFunctions.removeDuplicatesStringArray(colgroupBy);
            for (String groupby : colgroupBy) {
                    log.info("Adding : " + groupby);
                    String []arrgrp = groupby.split("\\.");
                    String sectionType = arrgrp[0];
                    String sectionName = arrgrp[1];
                    GroupedChange gparentNodeChange = new GroupedChange(sectionType, sectionName);
                    DefaultMutableTreeNode aNode = new DefaultMutableTreeNode(gparentNodeChange);
                    rootNode.add(aNode);
                        //now add changes for each of these sections
                    String qryChangsInDocOrder = reportEditableChangesByOrder_Queries.GET_CHANGES_BY_GROUP_IN_DOC_ORDER (CommonFunctions.getCurrentBillID(), groupby);
                    //SELECT doc_name, change_id, change_type, path_start, path_end, order_in_doc
                    QueryResults qr2 = db.ConnectAndQuery(qryChangsInDocOrder);
                    if (qr2.hasResults()) {
                        Iterator<Vector<String>> results = qr2.theResultsIterator();
                        while (results.hasNext()) {
                            Vector<String> row = results.next();
                            DocumentChange docChange = new DocumentChange(
                            qr2.getField(row, "DOC_NAME"),
                            qr2.getField(row, "CHANGE_ID"),
                            qr2.getField(row, "CHANGE_TYPE"),
                            qr2.getField(row, "PATH_START"),
                            qr2.getField(row, "PATH_END"),
                            qr2.getField(row, "ORDER_IN_DOC"),
                            qr2.getField(row, "OWNER") ,
                            qr2.getField(row, "CHANGE_DATE") ,
                            qr2.getField(row, "CHANGE_TEXT") ,
                            Integer.parseInt(qr2.getField(row, "ORDER_WEIGHT").toString())
                                    );
                            GroupedChange groupedChange = new GroupedChange (sectionType, sectionName, docChange);
                            DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(groupedChange);
                            aNode.add(childNode);
                            if (!gparentNodeChange.getSectionDeleteChange())
                                if (groupedChange.getObjType() == GroupedChange.OBJECT_TYPE.CHANGE) {
                                    if (groupedChange.getDocumentChange().getOrderWeight() == 0 ) {
                                        gparentNodeChange.setSectionDeleteChange(true);
                                        aNode.setUserObject(gparentNodeChange);
                                    }
                                }
                        }
                    }
            }
          DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);
          treeReportByOrder.setCellRenderer(new reportCellRenderer());
          treeReportByOrder.setModel(treeModel);
 

        }
        */

     public  void createAndShowGUI(JFrame parentFrame) {
                if (panelReportByOrder.thisFrame == null) {
                    panelReportByOrder.thisFrame = new JFrame("Report");
                    panelReportByOrder.thisFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
                    this.setParentFrame(parentFrame);
                    this.setPanelName("ReportByOrder");
                    panelReportByOrder.thisFrame.getContentPane().add(this);
                    panelReportByOrder.thisFrame.pack();
                    panelReportByOrder.thisFrame.setAlwaysOnTop(true);
                    panelReportByOrder.thisFrame.setVisible(true);
                } else {
                    if (thisFrame.isVisible()) {
                        thisFrame.requestFocus();
                    } else {
                        thisFrame.setVisible(true);
                        thisFrame.requestFocus();
                    }
                }
    }

    public boolean showUI(JFrame parentf) {
       createAndShowGUI(parentf);
       return true;
    }

    public boolean hasUICompleted() {
       return (!thisFrame.isVisible());
    }

    public boolean setProcessHook(IBungeniOdfDocumentReportProcess processHook) {
        this.reportProcess = processHook;
        return true;
    }

    public boolean setInputDocuments(BungeniOdfDocumentHelper[] dhelpers) {
        this.reportInputDocuments = dhelpers;
        return true;
    }

    public IBungeniOdfDocumentReportProcess getProcessHook(){
        return this.reportProcess;
    }

    private void initialize_listBoxes() {
       
    }

        
    public boolean initUI() {
            initialize();
            return true;
    }

    Component originalPane;

      /**
     * This covers the panel with a glass pane and runs the infinit progress bar.
     * Must be called before invoking the worker thread
     * @return
     */
    public boolean startProgress(){
        boolean bState = false;
        try {
            originalPane = thisFrame.getGlassPane();
            PerformanceInfiniteProgressPanel glassPane;
            thisFrame.setGlassPane(glassPane = new PerformanceInfiniteProgressPanel());
            glassPane.setVisible(true);
            bState = true;
        } catch (Exception ex) {
            log.error("startProgress : " + ex.getMessage());
        }
        return bState;
    }


    /**
     * This must be called only after a startProgress() api has been called.
     * stopProgress() is usually called when the worker threard completes , usually after
     * the get() api in SwingWorker.done().
     * @return
     */
    public boolean stopProgress() {
        boolean bState = false;
        try {
          final PerformanceInfiniteProgressPanel pPanel =
                  (PerformanceInfiniteProgressPanel) thisFrame.getGlassPane();
                   pPanel.setVisible(false);
                   thisFrame.setGlassPane(originalPane);
                   bState = true;
        } catch (Exception ex) {
            log.error("endProgress : " + ex.getMessage());
        }
        return bState;
    }


    class reportCellRenderer  extends DefaultTreeCellRenderer{

        Color deletedColor = Color.ORANGE;
        Color insertedColor = Color.BLUE;
        Color sectionColor = Color.MAGENTA;
        Color rootColor = Color.BLACK;
        Color zeroWeight = Color.RED;

        @Override
        public Component getTreeCellRendererComponent(JTree jtree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {
                Component c = super.getTreeCellRendererComponent(jtree, value, selected, expanded, leaf, row, hasFocus);
                if ((value != null) && (value instanceof DefaultMutableTreeNode)) {
                       DefaultMutableTreeNode dmt = ((DefaultMutableTreeNode) value);
                       Object userObject = dmt.getUserObject();
                       if (userObject instanceof GroupedChange) {
                           GroupedChange gc = (GroupedChange) userObject;
                           if (gc.getObjType() == GroupedChange.OBJECT_TYPE.CHANGE) {
                            /*    if (gc.getDocumentChange().getOrderWeight() == 0 ) {
                                    c.setForeground(zeroWeight);
                                    DefaultMutableTreeNode dmtParent = ((DefaultMutableTreeNode)dmt.getParent());
                                    GroupedChange gcParent = (GroupedChange) dmtParent.getUserObject();
                                    gcParent.setSectionDeleteChange(true);
                                    dmtParent.setUserObject(gcParent);
                                } else { */
                                    String cType = gc.getDocumentChange().getChangeType();
                                    if (cType.equals("deletion")) {
                                         c.setForeground(deletedColor);
                                    } else {
                                         c.setForeground(insertedColor);
                                    }
                                /*} */
                         } else
                           if (gc.getObjType() == GroupedChange.OBJECT_TYPE.ROOT) {
                                c.setForeground(rootColor);
                           } else
                           if (gc.getObjType() == GroupedChange.OBJECT_TYPE.SECTION) {
                              if (gc.getSectionDeleteChange()) {
                                    c.setForeground(zeroWeight);
                              } else {
                                   c.setForeground(sectionColor);
                              }
                           }
                       }
                }
                return c;
        }

    }
}
