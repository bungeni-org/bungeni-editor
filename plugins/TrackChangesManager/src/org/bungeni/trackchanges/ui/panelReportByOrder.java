package org.bungeni.trackchanges.ui;

import java.awt.Color;
import java.awt.Component;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Vector;
import java.util.concurrent.ExecutionException;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTree;
import javax.swing.SwingWorker;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import net.java.swingfx.waitwithstyle.PerformanceInfiniteProgressPanel;
import org.bungeni.db.BungeniClientDB;
import org.bungeni.db.QueryResults;
import org.bungeni.odfdocument.report.GeneratedReport;
import org.bungeni.odfdocument.report.IBungeniOdfDocumentReportProcess;
import org.bungeni.odfdocument.report.IBungeniOdfDocumentReportUI;
import org.bungeni.odfdom.document.BungeniOdfDocumentHelper;
import org.bungeni.odfdom.utils.BungeniOdfDateHelper;
import org.bungeni.reports.process.reportEditableChangesByOrder_Queries;
import org.bungeni.trackchanges.ui.GroupedChange.OBJECT_TYPE;
import org.bungeni.trackchanges.utils.CommonFunctions;

/**
 *
 * @author Ashok Hariharan
 */
public class panelReportByOrder extends panelChangesBase implements IBungeniOdfDocumentReportUI {
    private static org.apache.log4j.Logger log            =
        org.apache.log4j.Logger.getLogger(panelReportByOrder.class.getName());
    public static JFrame                   thisFrame = null;
    private IBungeniOdfDocumentReportProcess reportProcess = null;
    private BungeniOdfDocumentHelper[] reportInputDocuments;
    private String m_reportName = "";

    /** Creates new form panelReportByOrder */
    public panelReportByOrder() {
        super();
        initComponents();
    }

      public panelReportByOrder(JFrame parentFrm, String pName) {
           super(parentFrm, pName);
           initComponents();
     }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        btnMoveUp = new javax.swing.JButton();
        btnMoveDown = new javax.swing.JButton();
        btnFinish = new javax.swing.JButton();
        splitPane = new javax.swing.JSplitPane();
        scrollReport = new javax.swing.JScrollPane();
        treeReportByOrder = new javax.swing.JTree();
        scrollPane = new javax.swing.JScrollPane();
        treeContentPane = new javax.swing.JTextPane();
        lblStatus = new javax.swing.JLabel();

        btnMoveUp.setFont(new java.awt.Font("DejaVu Sans", 0, 10));
        btnMoveUp.setText("Move UP");
        btnMoveUp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnMoveUpActionPerformed(evt);
            }
        });

        btnMoveDown.setFont(new java.awt.Font("DejaVu Sans", 0, 10));
        btnMoveDown.setText("Move DOWN");
        btnMoveDown.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnMoveDownActionPerformed(evt);
            }
        });

        btnFinish.setFont(new java.awt.Font("DejaVu Sans", 0, 10));
        btnFinish.setText("Finish");

        splitPane.setDividerLocation(350);
        splitPane.setDividerSize(3);

        treeReportByOrder.setFont(new java.awt.Font("DejaVu Sans", 0, 10));
        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("Loading...");
        treeReportByOrder.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        scrollReport.setViewportView(treeReportByOrder);

        splitPane.setLeftComponent(scrollReport);

        treeContentPane.setEditable(false);
        treeContentPane.setFont(new java.awt.Font("DejaVu Sans", 0, 10));
        scrollPane.setViewportView(treeContentPane);

        splitPane.setRightComponent(scrollPane);

        lblStatus.setFont(new java.awt.Font("DejaVu Sans", 1, 11)); // NOI18N
        lblStatus.setText(" ");
        lblStatus.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(splitPane, javax.swing.GroupLayout.DEFAULT_SIZE, 463, Short.MAX_VALUE)
            .addGroup(layout.createSequentialGroup()
                .addComponent(btnMoveUp, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnMoveDown)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnFinish, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
            .addComponent(lblStatus, javax.swing.GroupLayout.DEFAULT_SIZE, 463, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(splitPane, javax.swing.GroupLayout.DEFAULT_SIZE, 295, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnMoveUp)
                    .addComponent(btnMoveDown)
                    .addComponent(btnFinish))
                .addGap(4, 4, 4)
                .addComponent(lblStatus))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void btnMoveUpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnMoveUpActionPerformed
        // TODO add your handling code here:
        promoteChangeInBranch();
    }//GEN-LAST:event_btnMoveUpActionPerformed

    private void btnMoveDownActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnMoveDownActionPerformed
        // TODO add your handling code here:
        demoteChangeInBranch();
    }//GEN-LAST:event_btnMoveDownActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnFinish;
    private javax.swing.JButton btnMoveDown;
    private javax.swing.JButton btnMoveUp;
    private javax.swing.JLabel lblStatus;
    private javax.swing.JScrollPane scrollPane;
    private javax.swing.JScrollPane scrollReport;
    private javax.swing.JSplitPane splitPane;
    private javax.swing.JTextPane treeContentPane;
    private javax.swing.JTree treeReportByOrder;
    // End of variables declaration//GEN-END:variables

    private void initialize() {
        PANEL_FILTER_REVIEW_STAGE = "ClerkConsolidationReview";
        PANEL_REVIEW_STAGE        = "";
       // loadFilesFromFolder();
        GeneratedReport aReport = lastReportExists();
        init_Tree(aReport);
    }


  

    private GeneratedReport lastReportExists () {
        GeneratedReport reportObj = null;
        BungeniClientDB db = BungeniClientDB.defaultConnect();
        //Always returns 1 row because of top 1 query
        QueryResults qr = db.ConnectAndQuery(reportEditableChangesByOrder_Queries.GET_NEWEST_REPORT_ID_FOR_BILL(CommonFunctions.getCurrentBillID(), this.m_reportName ));
        if (qr.hasResults()) {
            for (Vector<String> aRow : qr.theResults()) {
                String reportId = qr.getField(aRow, "REPORT_ID");
                String reportName = qr.getField(aRow, "REPORT_NAME");
                String genDate = qr.getField(aRow, "GENERATED_DATE");
                String userEditedName = qr.getField(aRow, "USER_EDITED_NAME");
                reportObj = new GeneratedReport(reportId, reportName, genDate, CommonFunctions.getCurrentBillID(), userEditedName);
                break;
            }
        }
        return reportObj;
    }

    private void init_Tree(GeneratedReport lastReport){
        //there was no lastReport
        if (null == lastReport) {
            load_Tree(TREE_LOADING_MODES.NEW, GeneratedReport.newGeneratedReport(m_reportName, CommonFunctions.getCurrentBillID()));
        } else {
            //there is a last report .. prompt the user if they want to see that or generate  new one
            final int nOption = JOptionPane.showConfirmDialog(this.parentFrame,
                    "There is a previous report of this type for the bill. \n" +
                    " Would you like to open the saved report ? Clicking no will regenerate report",
                    "Report generation",
                    JOptionPane.YES_NO_OPTION, 
                    JOptionPane.INFORMATION_MESSAGE);
           if (JOptionPane.YES_OPTION == nOption ) {
               //open the saved report
               load_Tree(TREE_LOADING_MODES.LOAD_RECENT, lastReport);
           }   else {
                //regenerate the report
                load_Tree(TREE_LOADING_MODES.UPDATE_RECENT, lastReport);
           }

            
          }
    }

    private void load_Tree(TREE_LOADING_MODES loadingMode, GeneratedReport genReport){
              startProgress();
              loadTreeWorker treeLoader = new loadTreeWorker(loadingMode, genReport);
              treeLoader.execute();
              this.treeContentPane.setContentType("text/html");
              this.treeReportByOrder.addTreeSelectionListener(new treeReportByOrderSelectionListener());
    }



    /**
     * This enum indicates states for "moving up" (promoting) and "moving down" (demoting) nodes in the report UI
     */
    public enum CHANGE_MOVEMENT { PROMOTE, DEMOTE }

    class PromoteDemoteChangeWorker extends SwingWorker {

        CHANGE_MOVEMENT changeMovement;
        DefaultMutableTreeNode dmtSelected ;
        DefaultTreeModel treeModel;
        DefaultMutableTreeNode dmtParent;
        GroupedChange gc , gcPrev;
        JButton thisButton ;

        /**
         * Promotes  / demotes a node
         * @param btn
         * @param cm
         */
        public PromoteDemoteChangeWorker (JButton btn,  CHANGE_MOVEMENT cm){
            this.thisButton = btn;
            this.changeMovement = cm;
            this.thisButton.setEnabled(false);
        }

        @Override
        protected Object doInBackground() throws Exception {
             // get the selected node
            dmtSelected = (DefaultMutableTreeNode) treeReportByOrder.getSelectionPath().getLastPathComponent();
            // get the tree model
            treeModel = (DefaultTreeModel)treeReportByOrder.getModel();
            // get the parent of the selected node
            dmtParent = (DefaultMutableTreeNode) dmtSelected.getParent();
            gc =  (GroupedChange) dmtSelected.getUserObject();
            return gc.getObjType();
        }

        @Override
        protected void done(){
            try {
                updateNode(get());
                thisButton.setEnabled(true);
            } catch (InterruptedException ex) {
               log.error(ex.getMessage());
            } catch (ExecutionException ex) {
               log.error(ex.getMessage());
            }

        }

        private void updateNode(Object fromGet){
                GroupedChange.OBJECT_TYPE objType = (OBJECT_TYPE) fromGet;
                DefaultMutableTreeNode dmtPrevNext = null;
                if (objType.equals(GroupedChange.OBJECT_TYPE.CHANGE)) {
                    if (changeMovement.equals(CHANGE_MOVEMENT.PROMOTE)) {
                         dmtPrevNext = dmtSelected.getPreviousSibling();
                    } else {
                         dmtPrevNext = dmtSelected.getNextSibling();
                    }
                    if (dmtPrevNext != null) {
                        gcPrev = (GroupedChange) dmtPrevNext.getUserObject();
                        Double tmpOrder = 0.0;
                        tmpOrder = gcPrev.getDocumentChange().getManualOrder();
                        gcPrev.getDocumentChange().setManualOrder(gc.getDocumentChange().getManualOrder());
                        gc.getDocumentChange().setManualOrder(tmpOrder);
                        dmtPrevNext.setUserObject(gc);
                        dmtSelected.setUserObject(gcPrev);

                        TreePath prevPath = new TreePath(dmtPrevNext.getPath());

                        final int[] childIndices = {
                            dmtParent.getIndex(dmtPrevNext),
                            dmtParent.getIndex(dmtSelected)
                        };

                        treeModel.nodesChanged(dmtParent, childIndices);
                        treeReportByOrder.setSelectionPath(prevPath);
                        // now update the order in the db.
                        BungeniClientDB db = BungeniClientDB.defaultConnect();
                        List<String> updates = new ArrayList<String>(0);

                        updates.add(reportEditableChangesByOrder_Queries.UPDATE_CHANGES_BY_ORDER_MANUAL_ORDER(CommonFunctions.getCurrentBillID(),
                                                                                                gcPrev.getDocumentChange().getChangeId(),
                                                                                                gcPrev.getDocumentChange().getManualOrder()));
                        updates.add(reportEditableChangesByOrder_Queries.UPDATE_CHANGES_BY_ORDER_MANUAL_ORDER(CommonFunctions.getCurrentBillID(),
                                                                                                gc.getDocumentChange().getChangeId(),
                                                                                                gc.getDocumentChange().getManualOrder()));
                        log.error("update : " + updates.get(0));
                        log.error("update : " + updates.get(1));
                        db.Connect();
                        db.Update(updates, true);
                        db.EndConnect();

                    }
                }

        }

    }


    private void promoteChangeInBranch(){
        PromoteDemoteChangeWorker worker = new PromoteDemoteChangeWorker(btnMoveUp, CHANGE_MOVEMENT.PROMOTE);
        worker.execute();
    }


    private void demoteChangeInBranch(){
        PromoteDemoteChangeWorker worker = new PromoteDemoteChangeWorker(btnMoveUp, CHANGE_MOVEMENT.DEMOTE);
        worker.execute();
    }

    class treeReportByOrderSelectionListener implements TreeSelectionListener {


          public treeReportByOrderSelectionListener(){
          }

          public void valueChanged(TreeSelectionEvent tse) {
                  DefaultMutableTreeNode node = (DefaultMutableTreeNode)
                       treeReportByOrder.getLastSelectedPathComponent();
                  if (node == null) {
                    //Nothing is selected.
                    return;
                  }
                  GroupedChange gc = (GroupedChange) node.getUserObject();
                  if (gc.getObjType() == GroupedChange.OBJECT_TYPE.CHANGE) {
                      String changeText = gc.getDocumentChange().getChangeText();
                      String changeType = gc.getDocumentChange().getChangeType();
                      if (changeType.equals("insertion")) {
                        treeContentPane.setText(getInsertStyle(changeText));
                      } else {
                        treeContentPane.setText(getDeleteStyle(changeText));
                      }
                  }
         }

          private String getInsertStyle (String text) {
              return "<html><span style='color:blue;'>" + text.replace("\n", "<br />") + "</span></html>";
          }

          private String getDeleteStyle (String text) {
              return "<html><s style='color:red;'>" + text.replace("\n", "<br />")  + "</s></html>";
          }

    }


    public enum TREE_LOADING_MODES { NEW, LOAD_RECENT, UPDATE_RECENT }

    class loadTreeWorker extends SwingWorker {

        final TREE_LOADING_MODES loadingMode;
        final GeneratedReport reportinfo ;
        public loadTreeWorker(TREE_LOADING_MODES loadMode, GeneratedReport rinfo){
            loadingMode = loadMode;
            reportinfo = rinfo;
        }

        @Override
        protected Object doInBackground() throws Exception {
             if (loadingMode.equals(TREE_LOADING_MODES.NEW)) {
                    getProcessHook().prepareProcess(reportInputDocuments, new HashMap<String,Object>(){
                        {
                         put ("REPORT_INFO", reportinfo);
                         put ("TREE_LOADING_MODE", loadingMode);
                        }
                    });
                    DefaultMutableTreeNode rootNode = loadTree();
                    return rootNode;
             } else if (loadingMode.equals(TREE_LOADING_MODES.LOAD_RECENT)) {
                    DefaultMutableTreeNode rootNode = loadTree();
                    return rootNode;
             } else {
                    getProcessHook().prepareProcess(reportInputDocuments, new HashMap<String,Object>(){
                        {
                        put ("REPORT_INFO", reportinfo);
                        put ("TREE_LOADING_MODE", loadingMode);
                        }
                    });
                    DefaultMutableTreeNode rootNode = loadTree();
                    return rootNode;
             }
        }

        @Override
        protected void done(){
                try {
                    DefaultMutableTreeNode dmtRoot = (DefaultMutableTreeNode) get();
                    if (dmtRoot != null )
                        displayTree(dmtRoot);
                    else
                        log.error("loadTreeWorker : prepare process returned NULL");
                    stopProgress();
                    for (int i = 0; i < treeReportByOrder.getRowCount(); i++) {
                            treeReportByOrder.expandRow(i);
                       }
                } catch (InterruptedException ex) {
                    log.error("Error while loading tree ", ex);
                } catch (ExecutionException ex) {
                    log.error("Error while loading tree ", ex);
                }
        }

        private void displayTree(DefaultMutableTreeNode dmtRoot) {
            if (dmtRoot != null) {
              DefaultTreeModel treeModel = new DefaultTreeModel(dmtRoot);
              treeReportByOrder.setCellRenderer(new reportCellRenderer());
              treeReportByOrder.setModel(treeModel);
            }
        }

        private DefaultMutableTreeNode loadTree(){
            DefaultMutableTreeNode dmtRoot = null;
            String query = reportEditableChangesByOrder_Queries.GET_ROOT_SECTION_HIERARCHY(CommonFunctions.getCurrentBillID());
            BungeniClientDB db = BungeniClientDB.defaultConnect();
            QueryResults qr = db.ConnectAndQuery(query);
            if (qr.hasResults()) {
                Vector<Vector<String>> results = qr.theResults();
                for (Vector<String> aRow : results) {
                    String rootSecId = qr.getField(aRow, "SECTION_ID");
                    String rootSecName = qr.getField(aRow, "SECTION_NAME");
                    String rootSecType = qr.getField(aRow, "SECTION_TYPE");
                    GroupedChange gc = new GroupedChange("root", "bill", rootSecId);
                    dmtRoot = new DefaultMutableTreeNode(gc);
                    //now look for all changes in the root section
                    /*
                    qr = db.ConnectAndQuery(reportEditableChangesByOrder_Queries.GET_CHANGES_BY_GROUP_IN_DOC_ORDER(CommonFunctions.getCurrentBillID(),
                               rootSecId));

                    if (qr.hasResults()) {
                        //add change nodes
                        qr.theResults();

                    }

                    //query child sections
                    */
                    processSubTreeHiearchy (db, CommonFunctions.getCurrentBillID(), dmtRoot, rootSecName, rootSecType, rootSecId );

                    }
                }
                return dmtRoot;
        }

        }

        private void processSubTreeHiearchy (BungeniClientDB db, String billId, DefaultMutableTreeNode dmtParent, String baseSecName, String baseSecType, String baseSecId  ) {

                QueryResults qr = db.ConnectAndQuery(reportEditableChangesByOrder_Queries.GET_CHANGES_BY_GROUP_IN_DOC_ORDER(CommonFunctions.getCurrentBillID(),
                               baseSecId));

                    if (qr.hasResults()) {
                        //add change nodes for this section
                        Vector<Vector<String>> results = qr.theResults();
                        for (Vector<String> aRow : results) {
                            DocumentChange docChange = new DocumentChange(
                            qr.getField(aRow, "DOC_NAME"),
                            qr.getField(aRow, "CHANGE_ID"),
                            qr.getField(aRow, "CHANGE_TYPE"),
                            qr.getField(aRow, "PATH_START"),
                            qr.getField(aRow, "PATH_END"),
                            qr.getField(aRow, "ORDER_IN_DOC"),
                            qr.getField(aRow, "OWNER") ,
                            qr.getField(aRow, "CHANGE_DATE") ,
                            qr.getField(aRow, "CHANGE_TEXT") ,
                            Integer.parseInt(qr.getField(aRow, "ORDER_WEIGHT").toString()),
                            Double.parseDouble(qr.getField(aRow, "MANUAL_ORDER"))
                                    );
                            GroupedChange groupedChange = new GroupedChange (baseSecName, baseSecType, baseSecId,  docChange);
                            DefaultMutableTreeNode dmtThis = new DefaultMutableTreeNode(groupedChange);
                            dmtParent.add(dmtThis);
                        }
                    }

                    //query child sections
                qr = db.ConnectAndQuery(reportEditableChangesByOrder_Queries.GET_SECTION_HIERARCHY(
                            CommonFunctions.getCurrentBillID(),
                            baseSecId
                            ));
                 if (qr.hasResults()) {
                     Vector<Vector<String>> results = qr.theResults();
                     for (Vector<String> aRow : results) {
                         String secId = qr.getField(aRow, "SECTION_ID");
                         String secName = qr.getField(aRow, "SECTION_NAME");
                         String secType  = qr.getField(aRow, "SECTION_TYPE");
                         GroupedChange gc = new GroupedChange(secName, secType, secId);
                         DefaultMutableTreeNode dmtSec = new DefaultMutableTreeNode(gc);
                         processSubTreeHiearchy(db, billId, dmtSec, secName, secType, secId);
                         dmtParent.add(dmtSec);
                     }
                 }


       }

        /*
        private void loadTree(){
            //the tree is loaded here
            DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(new GroupedChange("root", "bill"));
            String groupedQuery = reportEditableChangesByOrder_Queries.GET_CHANGE_GROUPS_BILL_BY_MANUAL_ORDER(CommonFunctions.getCurrentBillID());
            log.info ("loadTree : groupedQuery = " + groupedQuery);
            BungeniClientDB db = BungeniClientDB.defaultConnect();
            QueryResults qr = db.ConnectAndQuery(groupedQuery);
            String[] colgroupBy = qr.getSingleColumnResult("GROUP_BY");
            colgroupBy = CommonFunctions.removeDuplicatesStringArray(colgroupBy);
            for (String groupby : colgroupBy) {
                    log.info("Adding : " + groupby);
                    String []arrgrp = groupby.split("\\.");
                    String sectionType = arrgrp[0];
                    String sectionName = arrgrp[1];
                    GroupedChange gparentNodeChange = new GroupedChange(sectionType, sectionName);
                    DefaultMutableTreeNode aNode = new DefaultMutableTreeNode(gparentNodeChange);
                    rootNode.add(aNode);
                        //now add changes for each of these sections
                    String qryChangsInDocOrder = reportEditableChangesByOrder_Queries.GET_CHANGES_BY_GROUP_IN_DOC_ORDER (CommonFunctions.getCurrentBillID(), groupby);
                    //SELECT doc_name, change_id, change_type, path_start, path_end, order_in_doc
                    QueryResults qr2 = db.ConnectAndQuery(qryChangsInDocOrder);
                    if (qr2.hasResults()) {
                        Iterator<Vector<String>> results = qr2.theResultsIterator();
                        while (results.hasNext()) {
                            Vector<String> row = results.next();
                            DocumentChange docChange = new DocumentChange(
                            qr2.getField(row, "DOC_NAME"),
                            qr2.getField(row, "CHANGE_ID"),
                            qr2.getField(row, "CHANGE_TYPE"),
                            qr2.getField(row, "PATH_START"),
                            qr2.getField(row, "PATH_END"),
                            qr2.getField(row, "ORDER_IN_DOC"),
                            qr2.getField(row, "OWNER") ,
                            qr2.getField(row, "CHANGE_DATE") ,
                            qr2.getField(row, "CHANGE_TEXT") ,
                            Integer.parseInt(qr2.getField(row, "ORDER_WEIGHT").toString())
                                    );
                            GroupedChange groupedChange = new GroupedChange (sectionType, sectionName, docChange);
                            DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(groupedChange);
                            aNode.add(childNode);
                            if (!gparentNodeChange.getSectionDeleteChange())
                                if (groupedChange.getObjType() == GroupedChange.OBJECT_TYPE.CHANGE) {
                                    if (groupedChange.getDocumentChange().getOrderWeight() == 0 ) {
                                        gparentNodeChange.setSectionDeleteChange(true);
                                        aNode.setUserObject(gparentNodeChange);
                                    }
                                }
                        }
                    }
            }
          DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);
          treeReportByOrder.setCellRenderer(new reportCellRenderer());
          treeReportByOrder.setModel(treeModel);
 

        }
        */

     public  void createAndShowGUI(JFrame parentFrame) {
                if (panelReportByOrder.thisFrame == null) {
                    panelReportByOrder.thisFrame = new JFrame("Report");
                    panelReportByOrder.thisFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
                    this.setParentFrame(parentFrame);
                    this.setPanelName("ReportByOrder");
                    panelReportByOrder.thisFrame.getContentPane().add(this);
                    panelReportByOrder.thisFrame.pack();
                    panelReportByOrder.thisFrame.setAlwaysOnTop(true);
                    panelReportByOrder.thisFrame.setVisible(true);
                } else {
                    if (thisFrame.isVisible()) {
                        thisFrame.requestFocus();
                    } else {
                        thisFrame.setVisible(true);
                        thisFrame.requestFocus();
                    }
                }
    }

    public boolean showUI(JFrame parentf) {
       createAndShowGUI(parentf);
       return true;
    }

    public boolean hasUICompleted() {
       return (!thisFrame.isVisible());
    }

    public boolean setProcessHook(IBungeniOdfDocumentReportProcess processHook) {
        this.reportProcess = processHook;
        return true;
    }

    public boolean setInputDocuments(BungeniOdfDocumentHelper[] dhelpers) {
        this.reportInputDocuments = dhelpers;
        return true;
    }

    public IBungeniOdfDocumentReportProcess getProcessHook(){
        return this.reportProcess;
    }

    private void initialize_listBoxes() {
       
    }


    /**
     * This is called right after showUI
     * @return
     */
    public boolean initUI(HashMap<String,String> inputParams) {
            this.m_reportName = inputParams.get("REPORT_NAME");
            initialize();
            return true;
    }

    Component originalPane;

      /**
     * This covers the panel with a glass pane and runs the infinit progress bar.
     * Must be called before invoking the worker thread
     * @return
     */
    public boolean startProgress(){
        boolean bState = false;
        try {
            originalPane = thisFrame.getGlassPane();
            PerformanceInfiniteProgressPanel glassPane;
            thisFrame.setGlassPane(glassPane = new PerformanceInfiniteProgressPanel());
            glassPane.setVisible(true);
            bState = true;
        } catch (Exception ex) {
            log.error("startProgress : " + ex.getMessage());
        }
        return bState;
    }


    /**
     * This must be called only after a startProgress() api has been called.
     * stopProgress() is usually called when the worker threard completes , usually after
     * the get() api in SwingWorker.done().
     * @return
     */
    public boolean stopProgress() {
        boolean bState = false;
        try {
          final PerformanceInfiniteProgressPanel pPanel =
                  (PerformanceInfiniteProgressPanel) thisFrame.getGlassPane();
                   pPanel.setVisible(false);
                   thisFrame.setGlassPane(originalPane);
                   bState = true;
        } catch (Exception ex) {
            log.error("endProgress : " + ex.getMessage());
        }
        return bState;
    }


    class reportCellRenderer  extends DefaultTreeCellRenderer{

        Color deletedColor = Color.ORANGE;
        Color insertedColor = Color.BLUE;
        Color sectionColor = Color.MAGENTA;
        Color rootColor = Color.BLACK;
        Color zeroWeight = Color.RED;

        @Override
        public Component getTreeCellRendererComponent(JTree jtree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {
                Component c = super.getTreeCellRendererComponent(jtree, value, selected, expanded, leaf, row, hasFocus);
                if ((value != null) && (value instanceof DefaultMutableTreeNode)) {
                       DefaultMutableTreeNode dmt = ((DefaultMutableTreeNode) value);
                       Object userObject = dmt.getUserObject();
                       if (userObject instanceof GroupedChange) {
                           GroupedChange gc = (GroupedChange) userObject;
                           if (gc.getObjType() == GroupedChange.OBJECT_TYPE.CHANGE) {
                            /*    if (gc.getDocumentChange().getOrderWeight() == 0 ) {
                                    c.setForeground(zeroWeight);
                                    DefaultMutableTreeNode dmtParent = ((DefaultMutableTreeNode)dmt.getParent());
                                    GroupedChange gcParent = (GroupedChange) dmtParent.getUserObject();
                                    gcParent.setSectionDeleteChange(true);
                                    dmtParent.setUserObject(gcParent);
                                } else { */
                                    String cType = gc.getDocumentChange().getChangeType();
                                    if (cType.equals("deletion")) {
                                         c.setForeground(deletedColor);
                                    } else {
                                         c.setForeground(insertedColor);
                                    }
                                /*} */
                         } else
                           if (gc.getObjType() == GroupedChange.OBJECT_TYPE.ROOT) {
                                c.setForeground(rootColor);
                           } else
                           if (gc.getObjType() == GroupedChange.OBJECT_TYPE.SECTION) {
                              if (gc.getSectionDeleteChange()) {
                                    c.setForeground(zeroWeight);
                              } else {
                                   c.setForeground(sectionColor);
                              }
                           }
                       }
                }
                return c;
        }

    }
}
