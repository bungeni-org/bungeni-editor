#summary How to implement a complete action
#labels bungeni-editor

<wiki:toc max_depth="4" />

= 1 Define a toolbar action in toolbar xml =

== Elements in a toolbar xml config == 

 * _toolbar - this is a required root element in all action configurations
 * _root_ - All the actions are contained and grouped within the root element.  The root element suports a 'xsd:lang' attribute - and this allows localization of the action configurations.
 * _actionGroup_ - this element allows grouping contained actions into UI tabs
 * _blockAction_ - this element is rendered as a tab panel and contains actions
 * _action/subAction_ - these elements map to actual actions and appear as buttons on the UI.

_Figure : Toolbar XML Actions mapped to the rendered UI_
<img src="http://bungeni-editor.googlecode.com/files/Toolbar_Actions.png" alt="Toolbar XML Actions mapped to the rendered UI" />



== Adding a blockAction == 

Add a block action for the action.  A complete block action is illustrated below.

Example:
{{{

    <blockAction name="QA" tooltip="Create a QA Section" title="Papers" 
    	target="null" 
    	visible="true" 
    	condition="none" >
    	
        <action name="QA.selection" 
		title="From Selection" 
		mode="TEXT_SELECTED_INSERT" 
		target="toolbarSubAction.makeQA.section_creation" 
		condition="sectionNotExists:qa :and: textSelected:true" 
		visible="true" showChildren="true" >
		
                    <subaction name="QA.selection.title" 
				tooltip="Markup selection as title" 
				title="Markup Title" 
				mode="TEXT_SELECTED_INSERT" 
				target="toolbarSubAction.makeQASection.apply_style:qa" 
				visible="true" 
				condition="cursorInSection:qa :and: textSelected:true" />
				
                 </action>
    </blockAction>
}}}

The blockAction element is described here. 

{{{

    <blockAction name="QA" tooltip="Create a QA Section" title="Papers" 
    	target="null" 
    	visible="true" 
    	condition="none" >
}}}
`name` - the name attribute

`tooltip` - the tooltip text to display when mousing over the block action in the toolbar

`title` - the title text displayed in the toolbar

`visible` - true / false to display / hide the element

`target` - the address of the handler that is invoked upon clicking the toolbar item. Use _null_  - to indicate no action.

`condition` - conditions under which the action is displayed. If the condition evaluates to true - the button is enabled for clicking, if the condition evaluates to false, the button is in a disabled state. For condition processor documentation and syntax see: [http://code.google.com/p/bungeni-editor/wiki/ConditionProcessorsInBungeniEditor Condition Processors]

== Adding a Action element == 

blockActions can contain <action> elements.

The action element is described here.

{{{
   <action name="QA.selection" 
		title="From Selection" 
		mode="TEXT_SELECTED_INSERT" 
		target="toolbarSubAction.makeQA.section_creation" 
		condition="sectionNotExists:qa :and: textSelected:true" 
		visible="true" showChildren="true" >
}}}

`name` - the name of the action element

`title` - the title text displayed in the toolbar for the action

`mode` - applicable modes for this action. For modes and their description, see BungeniEditorModes

`target` - same as blockAction. in the example below, the target is :
{{{
target="toolbarSubAction.makeQA.section_creation"
}}}

The target syntax is a combination of "action_type.parent_action_name.sub_action_name" , out of these action_type can either be toolbarAction or toolbarSubAction, the other two values correspond to parent action, and sub action entries for the  target in the SUB_ACTION_SETTINGS table.

                                                                                                                                                                                 (There are 2 kinds of target actions possible, those that are defined in 'ACTION_SETTINGS' in the BungeniEditorSettingsDatabase and those that are defined in 'SUB_ACTION_SETTINGS'. 
For differences between the two action types see BungeniEditorActionTypes).



`showChildren`  - true / false enables/disables dispaly of child actions



== Adding a subAction element == 

<action> elements can contain <subAction> elements.
The subAction element is described here:

{{{
<subaction name="QA.selection.title" 
	tooltip="Markup selection as title" 
	title="Markup Title" 
	mode="TEXT_SELECTED_INSERT" 
	target="toolbarSubAction.makeQASection.apply_style:qa" 
	visible="true" 
	condition="cursorInSection:qa :and: textSelected:true" />
}}}

The attributes function exactly as described for the <action> element


== Schema for toolbar xml config == 

See this [http://code.google.com/p/bungeni-editor/source/browse/BungeniEditor/trunk/BungeniEditorClient/src/xsd/toolbar.xsd link]
{{{
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
  <xs:element name="toolbar">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="root"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="root">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="actionGroup"/>
      </xs:sequence>
      <xs:attribute name="lang" use="required" type="xs:NCName"/>
      <xs:attribute name="title" use="required"/>
      <xs:attribute name="visible" use="required" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="actionGroup">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="blockAction"/>
      </xs:sequence>
      <xs:attribute name="name" use="required" type="xs:NCName"/>
      <xs:attribute name="title" use="required" type="xs:NCName"/>
      <xs:attribute name="uimodel" use="required" type="xs:NCName"/>
      <xs:attribute name="visible" use="required" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="blockAction">
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element ref="action"/>
        <xs:element ref="subaction"/>
      </xs:choice>
      <xs:attribute name="condition" use="required" type="xs:NCName"/>
      <xs:attribute name="name" use="required"/>
      <xs:attribute name="showChildren" type="xs:boolean"/>
      <xs:attribute name="target" use="required" type="xs:NCName"/>
      <xs:attribute name="title" use="required"/>
      <xs:attribute name="tooltip"/>
      <xs:attribute name="visible" use="required" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="action">
    <xs:complexType>
      <xs:attribute name="condition" use="required" type="xs:anyURI"/>
      <xs:attribute name="mode" use="required" type="xs:NCName"/>
      <xs:attribute name="name" use="required" type="xs:NCName"/>
      <xs:attribute name="target" use="required"/>
      <xs:attribute name="title" use="required"/>
      <xs:attribute name="visible" use="required" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="subaction">
    <xs:complexType>
      <xs:attribute name="condition" use="required" type="xs:anyURI"/>
      <xs:attribute name="mode" use="required" type="xs:NCName"/>
      <xs:attribute name="name" use="required" type="xs:NCName"/>
      <xs:attribute name="target" use="required"/>
      <xs:attribute name="title" use="required"/>
      <xs:attribute name="tooltip"/>
      <xs:attribute name="visible" use="required" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
</xs:schema>


}}}



= 2 Calling a router action in response to a toolbar action =

Typically router actions, act on the document without requesting user interaction.
The router action is defined for the subAction in the ROUTER_CLASS column for the subAction in the 'SUB_ACTION_SETTINGS' table.
For information on how to write a router action, see HowToWriteaRouterAction.

= 3. Invoking dialogs in response to a toolbar action =

Clicking a toolbar action, can invoke the dialog that interacts with the currently selected openoffice document. This dialog (a JPanel) needs to extend the `selectorTemplatePanel` class and implement the `IBungeniForm` interface:

{{{
public  class InitPapers extends selectorTemplatePanel implements IBungeniForm {
.......
}
}}}

At runtime the Bungeni Editor invokes the panel by creating JDialog object and adding the panel to the JDialog.

for e.g. :
{{{
     dlg= new JDialog();
     dlg.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
     /*
     dialog panel class loaded and initialized here. the class name is retrieved from the toolbarSubAction object
    */
     IDialogSelector panel = DialogSelectorFactory.getDialogClass(subAction.dialog_class());
     panel.initObject(ooDocument, dlg, action, subAction);
     dlg.getContentPane().add(panel.getPanel());
     dlg.pack();
     dlg.setLocationRelativeTo(null);
     dlg.setVisible(true);
     dlg.setAlwaysOnTop(true);   
}}}

== Dialog class implementation requirements ==

=== Over-ride methods ===

The dialog class must necessarily extend the following methods :

This is used to initialize the dialog class :

{{{
public void initObject(OOComponentHelper ooDoc, JDialog dlg, toolbarAction act, toolbarSubAction subAct) {
    super.initObject( ooDoc, dlg, act, subAct);
    init();
    setControlModes();
}
}}}

This is invoked by the dialog class:

{{{ 
public void init(){
    super.init();
    initComponents();
    initFields();
}
}}}

This sets the formContext used by the form's command chain.  This is invoked by the base class init() function.

{{{
public void createContext(){
      super.createContext();
      formContext.setBungeniForm(this);
  }

}}}

This needs to be overriden by the derived class so the form's command chain handler can retrieve the appropriate command catalog based on the dialog class hierarchy.

{{{
public String getClassName(){
    return this.getClass().getName();
}
}}}

=== Naming form controls ===

For the contextual enabling/disabling of form controls, the form controls need to be explicitly named. This can be done using the dialog editor interface in netbeans (set the name attribute for the controls.).  The table 'ACTION_MODES' allows setting of control states based on mode.

||DOC_TYPE|| ACTION_NAME ||ACTION_MODE ||MODE_HIDDEN_FIELD ||SUB_ACTION_NAME||  
||debaterecord ||makePrayerSection ||TEXT_SELECTED_INSERT ||txt_initdebate_selectlogo ||debatedate_entry||
||debaterecord ||makePrayerSection ||TEXT_SELECTED_INSERT ||lbl_initdebate_selectlogo ||debatedate_entry||
||debaterecord ||makePrayerSection ||TEXT_SELECTED_INSERT ||txt_initdebate_selectlogo ||debatetime_entry||
||debaterecord ||makePrayerSection ||TEXT_SELECTED_INSERT ||lbl_initdebate_selectlogo ||debatetime_entry||
||debaterecord ||makePrayerSection ||TEXT_SELECTED_INSERT ||dt_initdebate_timeofhansard ||debatedate_entry||
||debaterecord ||makePrayerSection ||TEXT_SELECTED_INSERT ||dt_initdebate_hansarddate ||debatetime_entry||
||debaterecord ||makePaperSection ||TEXT_SELECTED_INSERT ||lbl_initpapers_title ||none||
||debaterecord ||makePaperSection ||TEXT_SELECTED_INSERT ||txt_initpapers_title ||none||

For e.g. the following settings:

||DOC_TYPE|| ACTION_NAME ||ACTION_MODE ||MODE_HIDDEN_FIELD ||SUB_ACTION_NAME||  
||debaterecord ||makePrayerSection ||TEXT_SELECTED_INSERT ||txt_initdebate_selectlogo ||debatedate_entry||
||debaterecord ||makePrayerSection ||TEXT_SELECTED_INSERT ||lbl_initdebate_selectlogo ||debatedate_entry||
||debaterecord ||makePrayerSection ||TEXT_SELECTED_INSERT ||dt_initdebate_timeofhansard ||debatedate_entry||

indicate that the controls named, 

||txt_initdebate_selectlogo ||
||lbl_initdebate_selectlogo ||
||dt_initdebate_timeofhansard ||

for the sub_action named 'debatedate_entry', will be hidden in TEXT_SELECTED_INSERT mode.

=== Handling form Submissions ===

Form submission is handled in the forms via a standard call back mechanism.  The base class 'selectorTemplatePanel' provides the following overridable API to trap events in specific modes :

{{{

 /** events invoked for TEXT_EDIT mode **/ 
  public boolean preFullEdit();
  public boolean postFullEdit();
  public boolean processFullEdit();

 /** events invoked for TEXT_INSERTION mode **/  
  public boolean preFullInsert();
  public boolean postFullInsert();
  public boolean processFullInsert();
  
 /** events invoked for TEXT_SELECTED_INSERT mode **/
  public boolean preSelectInsert();
  public boolean postSelectInsert();
  public boolean processSelectInsert();
 
}}}

The API functions are always invoked in the following order :

pre<mode function>() ==> process<mode function>() ==> post<mode function>() 




== Connecting the dialog class to the toolbar action == 

The dialog class is invoked via a standard interface by the bungeni editor. The above class for example needs to be specified in the `DIALOG_CLASS` column in the appropriate entry for the subAction in SUB_ACTION_SETTINGS table.